<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>Chapter&nbsp;1.&nbsp;Apache HBase Configuration</title><link rel="stylesheet" type="text/css" href="css/freebsd_docbook.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter" title="Chapter&nbsp;1.&nbsp;Apache HBase Configuration"><div class="titlepage"><div><div><h2 class="title"><a name="configuration"></a>Chapter&nbsp;1.&nbsp;Apache HBase Configuration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#basic.prerequisites">1.1. Basic Prerequisites</a></span></dt><dd><dl><dt><span class="section"><a href="#java">1.1.1. Java</a></span></dt><dt><span class="section"><a href="#os">1.1.2. Operating System</a></span></dt><dt><span class="section"><a href="#hadoop">1.1.3. Hadoop</a></span></dt></dl></dd><dt><span class="section"><a href="#standalone_dist">1.2. HBase run modes: Standalone and Distributed</a></span></dt><dd><dl><dt><span class="section"><a href="#standalone">1.2.1. Standalone HBase</a></span></dt><dt><span class="section"><a href="#distributed">1.2.2. Distributed</a></span></dt><dt><span class="section"><a href="#confirm">1.2.3. Running and Confirming Your Installation</a></span></dt></dl></dd><dt><span class="section"><a href="#config.files">1.3. Configuration Files</a></span></dt><dd><dl><dt><span class="section"><a href="#hbase.site">1.3.1. <code class="filename">hbase-site.xml</code> and <code class="filename">hbase-default.xml</code></a></span></dt><dt><span class="section"><a href="#hbase.env.sh">1.3.2. <code class="filename">hbase-env.sh</code></a></span></dt><dt><span class="section"><a href="#log4j">1.3.3. <code class="filename">log4j.properties</code></a></span></dt><dt><span class="section"><a href="#client_dependencies">1.3.4. Client configuration and dependencies connecting to an HBase cluster</a></span></dt></dl></dd><dt><span class="section"><a href="#example_config">1.4. Example Configurations</a></span></dt><dd><dl><dt><span class="section"><a href="#d4651e2390">1.4.1. Basic Distributed HBase Install</a></span></dt></dl></dd><dt><span class="section"><a href="#important_configurations">1.5. The Important Configurations</a></span></dt><dd><dl><dt><span class="section"><a href="#required_configuration">1.5.1. Required Configurations</a></span></dt><dt><span class="section"><a href="#recommended_configurations">1.5.2. Recommended Configurations</a></span></dt><dt><span class="section"><a href="#other_configuration">1.5.3. Other Configurations</a></span></dt></dl></dd></dl></div><p>This chapter is the Not-So-Quick start guide to Apache HBase configuration.  It goes
    over system requirements, Hadoop setup, the different Apache HBase run modes, and the
    various configurations in HBase.  Please read this chapter carefully.  At a mimimum
    ensure that all <a class="xref" href="#basic.prerequisites" title="1.1.&nbsp;Basic Prerequisites">Section&nbsp;1.1, &#8220;Basic Prerequisites&#8221;</a> have
      been satisfied.  Failure to do so will cause you (and us) grief debugging strange errors
      and/or data loss.</p><p>
        Apache HBase uses the same configuration system as Apache Hadoop.
        To configure a deploy, edit a file of environment variables
        in <code class="filename">conf/hbase-env.sh</code> -- this configuration
        is used mostly by the launcher shell scripts getting the cluster
        off the ground -- and then add configuration to an XML file to
        do things like override HBase defaults, tell HBase what Filesystem to
        use, and the location of the ZooKeeper ensemble
        <sup>[<a name="d4651e14" href="#ftn.d4651e14" class="footnote">1</a>]</sup>
        .
    </p><p>When running in distributed mode, after you make
    an edit to an HBase configuration, make sure you copy the
    content of the <code class="filename">conf</code> directory to
    all nodes of the cluster.  HBase will not do this for you.
    Use <span class="command"><strong>rsync</strong></span>.</p><div class="section" title="1.1.&nbsp;Basic Prerequisites"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="basic.prerequisites"></a>1.1.&nbsp;Basic Prerequisites</h2></div></div></div><p>This section lists required services and some required system configuration.
    </p><div class="section" title="1.1.1.&nbsp;Java"><div class="titlepage"><div><div><h3 class="title"><a name="java"></a>1.1.1.&nbsp;Java</h3></div></div></div><p>Just like Hadoop, HBase requires at least Java 6 from
        <a class="link" href="http://www.java.com/download/" target="_top">Oracle</a>.
        Java 7 should work and can even be faster than Java 6, but almost all testing
        has been done on the latter at this point.</p></div><div class="section" title="1.1.2.&nbsp;Operating System"><div class="titlepage"><div><div><h3 class="title"><a name="os"></a>1.1.2.&nbsp;Operating System</h3></div></div></div><div class="section" title="1.1.2.1.&nbsp;ssh"><div class="titlepage"><div><div><h4 class="title"><a name="ssh"></a>1.1.2.1.&nbsp;ssh</h4></div></div></div><p><span class="command"><strong>ssh</strong></span> must be installed and
        <span class="command"><strong>sshd</strong></span> must be running to use Hadoop's scripts to
        manage remote Hadoop and HBase daemons. You must be able to ssh to all
        nodes, including your local node, using passwordless login (Google
        "ssh passwordless login").  If on mac osx, see the section,
        <a class="link" href="http://wiki.apache.org/hadoop/Running_Hadoop_On_OS_X_10.5_64-bit_%28Single-Node_Cluster%29" target="_top">SSH: Setting up Remote Desktop and Enabling Self-Login</a>
        on the hadoop wiki.</p></div><div class="section" title="1.1.2.2.&nbsp;DNS"><div class="titlepage"><div><div><h4 class="title"><a name="dns"></a>1.1.2.2.&nbsp;DNS</h4></div></div></div><p>HBase uses the local hostname to self-report its IP address.
        Both forward and reverse DNS resolving must work in versions of
        HBase previous to 0.92.0
        <sup>[<a name="d4651e63" href="#ftn.d4651e63" class="footnote">2</a>]</sup>.</p><p>If your machine has multiple interfaces, HBase will use the
        interface that the primary hostname resolves to.</p><p>If this is insufficient, you can set
        <code class="varname">hbase.regionserver.dns.interface</code> to indicate the
        primary interface. This only works if your cluster configuration is
        consistent and every host has the same network interface
        configuration.</p><p>Another alternative is setting
        <code class="varname">hbase.regionserver.dns.nameserver</code> to choose a
        different nameserver than the system wide default.</p></div><div class="section" title="1.1.2.3.&nbsp;Loopback IP"><div class="titlepage"><div><div><h4 class="title"><a name="loopback.ip"></a>1.1.2.3.&nbsp;Loopback IP</h4></div></div></div><p>HBase expects the loopback IP address to be 127.0.0.1.  See <a class="xref" href="#loopback.ip" title="1.1.2.3.&nbsp;Loopback IP">Section&nbsp;1.1.2.3, &#8220;Loopback IP&#8221;</a></p></div><div class="section" title="1.1.2.4.&nbsp;NTP"><div class="titlepage"><div><div><h4 class="title"><a name="ntp"></a>1.1.2.4.&nbsp;NTP</h4></div></div></div><p>The clocks on cluster members should be in basic alignments.
        Some skew is tolerable but wild skew could generate odd behaviors. Run
        <a class="link" href="http://en.wikipedia.org/wiki/Network_Time_Protocol" target="_top">NTP</a>
        on your cluster, or an equivalent.</p><p>If you are having problems querying data, or "weird" cluster
        operations, check system time!</p></div><div class="section" title="1.1.2.5.&nbsp; ulimit and nproc"><div class="titlepage"><div><div><h4 class="title"><a name="ulimit"></a>1.1.2.5.&nbsp;
          <code class="varname">ulimit</code><a class="indexterm" name="d4651e103"></a>
            and
          <code class="varname">nproc</code><a class="indexterm" name="d4651e109"></a>
        </h4></div></div></div><p>Apache HBase is a database.  It uses a lot of files all at the same time.
        The default ulimit -n -- i.e. user file limit -- of 1024 on most *nix systems
        is insufficient (On mac os x its 256). Any significant amount of loading will
        lead you to <a class="xref" href="#">???</a>.
        You may also notice errors such as... </p><pre class="programlisting">
      2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Exception increateBlockOutputStream java.io.EOFException
      2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Abandoning block blk_-6935524980745310745_1391901
      </pre><p> Do yourself a favor and change the upper bound on the
        number of file descriptors. Set it to north of 10k.  The math runs roughly as follows:  per ColumnFamily
        there is at least one StoreFile and possibly up to 5 or 6 if the region is under load.  Multiply the
        average number of StoreFiles per ColumnFamily times the number of regions per RegionServer.  For example, assuming
        that a schema had 3 ColumnFamilies per region with an average of 3 StoreFiles per ColumnFamily,
        and there are 100 regions per RegionServer, the JVM will open 3 * 3 * 100 = 900 file descriptors
        (not counting open jar files, config files, etc.)
        </p><p>You should also up the hbase users'
        <code class="varname">nproc</code> setting; under load, a low-nproc
        setting could manifest as <code class="classname">OutOfMemoryError</code>
        <sup>[<a name="d4651e128" href="#ftn.d4651e128" class="footnote">3</a>]</sup>
        <sup>[<a name="d4651e135" href="#ftn.d4651e135" class="footnote">4</a>]</sup>.
       </p><p>To be clear, upping the file descriptors and nproc for the user who is
        running the HBase process is an operating system configuration, not an
        HBase configuration. Also, a common mistake is that administrators
        will up the file descriptors for a particular user but for whatever
        reason, HBase will be running as some one else. HBase prints in its
        logs as the first line the ulimit its seeing. Ensure its correct.
        <sup>[<a name="d4651e147" href="#ftn.d4651e147" class="footnote">5</a>]</sup></p><div class="section" title="1.1.2.5.1.&nbsp;ulimit on Ubuntu"><div class="titlepage"><div><div><h5 class="title"><a name="ulimit_ubuntu"></a>1.1.2.5.1.&nbsp;<code class="varname">ulimit</code> on Ubuntu</h5></div></div></div><p>If you are on Ubuntu you will need to make the following
          changes:</p><p>In the file <code class="filename">/etc/security/limits.conf</code> add
          a line like: </p><pre class="programlisting">hadoop  -       nofile  32768</pre><p>
          Replace <code class="varname">hadoop</code> with whatever user is running
          Hadoop and HBase. If you have separate users, you will need 2
          entries, one for each user.  In the same file set nproc hard and soft
          limits.  For example: </p><pre class="programlisting">hadoop soft/hard nproc 32000</pre><p>.</p><p>In the file <code class="filename">/etc/pam.d/common-session</code> add
          as the last line in the file: </p><pre class="programlisting">session required  pam_limits.so</pre><p>
          Otherwise the changes in <code class="filename">/etc/security/limits.conf</code> won't be
          applied.</p><p>Don't forget to log out and back in again for the changes to
          take effect!</p></div></div><div class="section" title="1.1.2.6.&nbsp;Windows"><div class="titlepage"><div><div><h4 class="title"><a name="windows"></a>1.1.2.6.&nbsp;Windows</h4></div></div></div><p>Apache HBase has been little tested running on Windows. Running a
        production install of HBase on top of Windows is not
        recommended.</p><p>If you are running HBase on Windows, you must install <a class="link" href="http://cygwin.com/" target="_top">Cygwin</a> to have a *nix-like
        environment for the shell scripts. The full details are explained in
        the <a class="link" href="http://hbase.apache.org/cygwin.html" target="_top">Windows
        Installation</a> guide. Also
        <a class="link" href="http://search-hadoop.com/?q=hbase+windows&amp;fc_project=HBase&amp;fc_type=mail+_hash_+dev" target="_top">search our user mailing list</a> to pick
        up latest fixes figured by Windows users.</p></div></div><div class="section" title="1.1.3.&nbsp;Hadoop"><div class="titlepage"><div><div><h3 class="title"><a name="hadoop"></a>1.1.3.&nbsp;<a class="link" href="http://hadoop.apache.org" target="_top">Hadoop</a><a class="indexterm" name="d4651e207"></a></h3></div></div></div><p>Selecting a Hadoop version is critical for your HBase deployment.
              Below table shows some information about what versions of Hadoop are supported by various HBase versions.
              Based on the version of HBase, you should select the most appropriate version of Hadoop.
              We are not in the Hadoop distro selection business.
              You can use Hadoop distributions from Apache, or learn about vendor distributions of
              Hadoop at <a class="link" href="http://wiki.apache.org/hadoop/Distributions%20and%20Commercial%20Support" target="_top">http://wiki.apache.org/hadoop/Distributions%20and%20Commercial%20Support</a></p><p>
             </p><div class="tip" title="Hadoop 2.x is better than Hadoop 1.x" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Hadoop 2.x is better than Hadoop 1.x</h3><p>Hadoop 2.x is faster, with more features such as short-circuit reads which will help improve your
                     HBase random read profile as well important bug fixes that will improve your overall HBase experience.
                     You should run Hadoop 2. rather than Hadoop 1. if you can.
             </p></div><p>
	     </p><div class="table"><a name="d4651e221"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;Hadoop version support matrix</b></p><div class="table-contents"><table summary="Hadoop version support matrix" border="1"><colgroup><col align="left" class="c1"><col align="center" class="c2"><col align="center" class="c3"><col align="center" class="c4"></colgroup><thead><tr><th align="left">               </th><th align="center">HBase-0.92.x</th><th align="center">HBase-0.94.x</th><th align="center">HBase-0.96.0</th></tr></thead><tbody><tr><td align="left">Hadoop-0.20.205</td><td align="center">S</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Hadoop-0.22.x  </td><td align="center">S</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Hadoop-1.0.0-1.0.2<sup>[<a name="d4651e261" href="#ftn.d4651e261" class="footnote">a</a>]</sup>   </td><td align="center">S</td><td align="center">S</td><td align="center">X</td></tr><tr><td align="left">Hadoop-1.0.3+</td><td align="center">S</td><td align="center">S</td><td align="center">S</td></tr><tr><td align="left">Hadoop-1.1.x   </td><td align="center">NT</td><td align="center">S</td><td align="center">S</td></tr><tr><td align="left">Hadoop-0.23.x  </td><td align="center">X</td><td align="center">S</td><td align="center">NT</td></tr><tr><td align="left">Hadoop-2.0.x-alpha     </td><td align="center">X</td><td align="center">NT</td><td align="center">X</td></tr><tr><td align="left">Hadoop-2.1.0-beta     </td><td align="center">X</td><td align="center">NT</td><td align="center">S</td></tr><tr><td align="left">Hadoop-2.x     </td><td align="center">X</td><td align="center">NT</td><td align="center">S</td></tr></tbody><tbody class="footnotes"><tr><td colspan="4"><div class="footnote"><p><sup>[<a id="ftn.d4651e261" href="#d4651e261" class="para">a</a>] </sup>HBase requires hadoop 1.0.3 at a minimum; there is an issue where we cannot find KerberosUtil compiling against earlier versions of Hadoop.</p></div></td></tr></tbody></table></div></div><p><br class="table-break">

        Where
		</p><table border="0" summary="Simple list" class="simplelist"><tr><td>S = supported and tested,</td></tr><tr><td>X = not supported,</td></tr><tr><td>NT = it should run, but not tested enough.</td></tr></table><p>
        </p><p>
	Because HBase depends on Hadoop, it bundles an instance of the Hadoop jar under its <code class="filename">lib</code> directory. The bundled jar is ONLY for use in standalone mode. In distributed mode, it is <span class="emphasis"><em>critical</em></span> that the version of Hadoop that is out on your cluster match what is under HBase. Replace the hadoop jar found in the HBase lib directory with the hadoop jar you are running on your cluster to avoid version mismatch issues. Make sure you replace the jar in HBase everywhere on your cluster. Hadoop version mismatch issues have various manifestations but often all looks like its hung up.
    </p><div class="section" title="1.1.3.1.&nbsp;Apache HBase 0.92 and 0.94"><div class="titlepage"><div><div><h4 class="title"><a name="hadoop.hbase-0.94"></a>1.1.3.1.&nbsp;Apache HBase 0.92 and 0.94</h4></div></div></div><p>HBase 0.92 and 0.94 versions can work with Hadoop versions, 0.20.205, 0.22.x, 1.0.x, and 1.1.x. HBase-0.94 can additionally work with Hadoop-0.23.x and 2.x, but you may have to recompile the code using the specific maven profile (see top level pom.xml)</p></div><div class="section" title="1.1.3.2.&nbsp;Apache HBase 0.96"><div class="titlepage"><div><div><h4 class="title"><a name="hadoop.hbase-0.96"></a>1.1.3.2.&nbsp;Apache HBase 0.96</h4></div></div></div><p>Apache HBase 0.96.0 requires Apache Hadoop 1.x at a minimum, and it can run equally well on hadoop-2.0.
	As of Apache HBase 0.96.x, Apache Hadoop 1.0.x at least is required. We will no longer run properly on older Hadoops such as 0.20.205 or branch-0.20-append. Do not move to Apache HBase 0.96.x if you cannot upgrade your Hadoop<sup>[<a name="d4651e352" href="#ftn.d4651e352" class="footnote">6</a>]</sup>.</p></div><div class="section" title="1.1.3.3.&nbsp;Hadoop versions 0.20.x - 1.x"><div class="titlepage"><div><div><h4 class="title"><a name="hadoop.older.versions"></a>1.1.3.3.&nbsp;Hadoop versions 0.20.x - 1.x</h4></div></div></div><p>
     HBase will lose data unless it is running on an HDFS that has a durable
        <code class="code">sync</code> implementation.  DO NOT use Hadoop 0.20.2, Hadoop 0.20.203.0, and Hadoop 0.20.204.0 which DO NOT have this attribute. Currently only Hadoop versions 0.20.205.x or any release in excess of this version -- this includes hadoop-1.0.0 -- have a working, durable sync
          <sup>[<a name="d4651e366" href="#ftn.d4651e366" class="footnote">7</a>]</sup>.  Sync has to be explicitly enabled by setting
        <code class="varname">dfs.support.append</code> equal
        to true on both the client side -- in <code class="filename">hbase-site.xml</code>
        -- and on the serverside in <code class="filename">hdfs-site.xml</code> (The sync
        facility HBase needs is a subset of the append code path).
        </p><pre class="programlisting">
  &lt;property&gt;
    &lt;name&gt;dfs.support.append&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;
        </pre><p>
        You will have to restart your cluster after making this edit.  Ignore the chicken-little
        comment you'll find in the <code class="filename">hdfs-default.xml</code> in the
        description for the <code class="varname">dfs.support.append</code> configuration.
     </p></div><div class="section" title="1.1.3.4.&nbsp;Apache HBase on Secure Hadoop"><div class="titlepage"><div><div><h4 class="title"><a name="hadoop.security"></a>1.1.3.4.&nbsp;Apache HBase on Secure Hadoop</h4></div></div></div><p>Apache HBase will run on any Hadoop 0.20.x that incorporates Hadoop
          security features as long as you do as
          suggested above and replace the Hadoop jar that ships with HBase
          with the secure version.  If you want to read more about how to setup
          Secure HBase, see <a class="xref" href="#">???</a>.</p></div><div class="section" title="1.1.3.5.&nbsp;dfs.datanode.max.xcievers"><div class="titlepage"><div><div><h4 class="title"><a name="dfs.datanode.max.xcievers"></a>1.1.3.5.&nbsp;<code class="varname">dfs.datanode.max.xcievers</code><a class="indexterm" name="d4651e402"></a></h4></div></div></div><p>An Hadoop HDFS datanode has an upper bound on the number of
        files that it will serve at any one time. The upper bound parameter is
        called <code class="varname">xcievers</code> (yes, this is misspelled). Again,
        before doing any loading, make sure you have configured Hadoop's
        <code class="filename">conf/hdfs-site.xml</code> setting the
        <code class="varname">xceivers</code> value to at least the following:
        </p><pre class="programlisting">
      &lt;property&gt;
        &lt;name&gt;dfs.datanode.max.xcievers&lt;/name&gt;
        &lt;value&gt;4096&lt;/value&gt;
      &lt;/property&gt;
      </pre><p>Be sure to restart your HDFS after making the above
        configuration.</p><p>Not having this configuration in place makes for strange looking
        failures. Eventually you'll see a complain in the datanode logs
        complaining about the xcievers exceeded, but on the run up to this one
        manifestation is complaint about missing blocks. For example:
        <code class="code">10/12/08 20:10:31 INFO hdfs.DFSClient: Could not obtain block
        blk_XXXXXXXXXXXXXXXXXXXXXX_YYYYYYYY from any node:
        java.io.IOException: No live nodes contain current block. Will get new
        block locations from namenode and retry...</code>
        <sup>[<a name="d4651e425" href="#ftn.d4651e425" class="footnote">8</a>]</sup></p><p>See also <a class="xref" href="#">???</a>
       </p></div></div></div><div class="section" title="1.2.&nbsp;HBase run modes: Standalone and Distributed"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="standalone_dist"></a>1.2.&nbsp;HBase run modes: Standalone and Distributed</h2></div></div></div><p>HBase has two run modes: <a class="xref" href="#standalone" title="1.2.1.&nbsp;Standalone HBase">Section&nbsp;1.2.1, &#8220;Standalone HBase&#8221;</a> and <a class="xref" href="#distributed" title="1.2.2.&nbsp;Distributed">Section&nbsp;1.2.2, &#8220;Distributed&#8221;</a>. Out of the box, HBase runs in
          standalone mode.  Whatever your mode, you will need to configure HBase by editing files in the HBase <code class="filename">conf</code>
      directory.  At a minimum, you must edit <code class="code">conf/hbase-env.sh</code> to tell HBase which
      <span class="command"><strong>java</strong></span> to use. In this file you set HBase environment
      variables such as the heapsize and other options for the
      <span class="application">JVM</span>, the preferred location for log files,
      etc. Set <code class="varname">JAVA_HOME</code> to point at the root of your
      <span class="command"><strong>java</strong></span> install.</p><div class="section" title="1.2.1.&nbsp;Standalone HBase"><div class="titlepage"><div><div><h3 class="title"><a name="standalone"></a>1.2.1.&nbsp;Standalone HBase</h3></div></div></div><p>This is the default mode. Standalone mode is what is described
            in the <a class="xref" href="#">???</a> section. In
        standalone mode, HBase does not use HDFS -- it uses the local
        filesystem instead -- and it runs all HBase daemons and a local
        ZooKeeper all up in the same JVM. Zookeeper binds to a well known port
        so clients may talk to HBase.</p></div><div class="section" title="1.2.2.&nbsp;Distributed"><div class="titlepage"><div><div><h3 class="title"><a name="distributed"></a>1.2.2.&nbsp;Distributed</h3></div></div></div><p>Distributed mode can be subdivided into distributed but all
        daemons run on a single node -- a.k.a
        <span class="emphasis"><em>pseudo-distributed</em></span>-- and
        <span class="emphasis"><em>fully-distributed</em></span> where the daemons are spread
        across all nodes in the cluster <sup>[<a name="d4651e481" href="#ftn.d4651e481" class="footnote">9</a>]</sup>.</p><p>Pseudo-distributed mode can run against the local filesystem or
              it can run against an instance of the <span class="emphasis"><em>Hadoop
                  Distributed File System</em></span> (HDFS). Fully-distributed mode can
              ONLY run on HDFS. See the Hadoop <a class="link" href="http://hadoop.apache.org/common/docs/r1.1.1/api/overview-summary.html#overview_description" target="_top">
        requirements and instructions</a> for how to set up HDFS.</p><p>Below we describe the different distributed setups. Starting,
        verification and exploration of your install, whether a
        <span class="emphasis"><em>pseudo-distributed</em></span> or
        <span class="emphasis"><em>fully-distributed</em></span> configuration is described in a
        section that follows, <a class="xref" href="#confirm" title="1.2.3.&nbsp;Running and Confirming Your Installation">Section&nbsp;1.2.3, &#8220;Running and Confirming Your Installation&#8221;</a>. The same verification script applies to both
        deploy types.</p><div class="section" title="1.2.2.1.&nbsp;Pseudo-distributed"><div class="titlepage"><div><div><h4 class="title"><a name="pseudo"></a>1.2.2.1.&nbsp;Pseudo-distributed</h4></div></div></div><p>A pseudo-distributed mode is simply a fully-distributed mode run on
          a single host. Use this configuration testing and prototyping on
          HBase. Do not use this configuration for production nor for
          evaluating HBase performance.</p><p>First, if you want to run on HDFS rather than on the local filesystem,
          setup your HDFS.  You can set up HDFS also in
          <a class="link" href="http://hadoop.apache.org/docs/r1.0.3/single_node_setup.html" target="_top">pseudo-distributed mode</a>.
          Ensure you have a working HDFS before proceeding.
   	      </p><p>Next, configure HBase.  Edit <code class="filename">conf/hbase-site.xml</code>.
              This is the file into which you add local customizations and overrides.
          At a minimum, you must tell HBase to run in (pseudo-)distributed mode rather than
          in default standalone mode.  To do this, set the <code class="varname">hbase.cluster.distributed</code>
          property to true (Its default is <code class="varname">false</code>).  The absolute bare-minimum
          <code class="filename">hbase-site.xml</code> is therefore as follows:
</p><pre class="programlisting">
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;
&lt;/configuration&gt;
</pre><p>
With this configuration, HBase will start up an HBase Master process, a ZooKeeper server,
and a RegionServer process running against the
local filesystem writing to wherever your operating system stores temporary files into a directory
named <code class="filename">hbase-YOUR_USER_NAME</code>.</p><p>Such a setup, using the local filesystem and
writing to the operating systems's temporary directory is an ephemeral setup; the Hadoop
local filesystem -- which is what HBase uses when it is writing the local filesytem does not
support <span class="command"><strong>sync</strong></span> so unless the system is shutdown properly, the data will be lost.  Writing to
the operating system's temporary directory can also make for data loss when the machine
is restarted as this directory is usually cleared on reboot.  For a more permanent
setup, see the next example where we make use of an instance of HDFS; HBase data will
be written to the Hadoop distributed filesystem rather than to the local filesystem's
tmp directory.</p><p>In this <code class="filename">conf/hbase-site.xml</code> example, the
<code class="varname">hbase.rootdir</code> property points to the local HDFS instance
homed on the node <code class="varname">h-24-30.example.com</code>.
          </p><div class="note" title="Let HBase create ${hbase.rootdir}" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Let HBase create <code class="filename">${hbase.rootdir}</code></h3><p>Let HBase create the <code class="varname">hbase.rootdir</code>
            directory. If you don't, you'll get warning saying HBase needs a
            migration run because the directory is missing files expected by
            HBase (it'll create them if you let it).</p></div><p>
</p><pre class="programlisting">
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.rootdir&lt;/name&gt;
    &lt;value&gt;hdfs://h-24-30.sfo.stumble.net:8020/hbase&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;
&lt;/configuration&gt;
</pre><p>
</p><p>Now skip to <a class="xref" href="#confirm" title="1.2.3.&nbsp;Running and Confirming Your Installation">Section&nbsp;1.2.3, &#8220;Running and Confirming Your Installation&#8221;</a> for how to start and verify your
          pseudo-distributed install. <sup>[<a name="d4651e567" href="#ftn.d4651e567" class="footnote">10</a>]</sup></p><div class="section" title="1.2.2.1.1.&nbsp;Pseudo-distributed Extras"><div class="titlepage"><div><div><h5 class="title"><a name="pseudo.extras"></a>1.2.2.1.1.&nbsp;Pseudo-distributed Extras</h5></div></div></div><div class="section" title="1.2.2.1.1.1.&nbsp;Startup"><div class="titlepage"><div><div><h6 class="title"><a name="pseudo.extras.start"></a>1.2.2.1.1.1.&nbsp;Startup</h6></div></div></div><p>To start up the initial HBase cluster...
                   </p><pre class="programlisting">% bin/start-hbase.sh</pre><p>
                </p><p>To start up an extra backup master(s) on the same server run...
                       </p><pre class="programlisting">% bin/local-master-backup.sh start 1</pre><p>
                       ... the '1' means use ports 60001 &amp; 60011, and this backup master's logfile will be at <code class="filename">logs/hbase-${USER}-1-master-${HOSTNAME}.log</code>.
                </p><p>To startup multiple backup masters run... </p><pre class="programlisting">% bin/local-master-backup.sh start 2 3</pre><p> You can start up to 9 backup masters (10 total).
 				</p><p>To start up more regionservers...
     			  </p><pre class="programlisting">% bin/local-regionservers.sh start 1</pre><p>
     			where '1' means use ports 60201 &amp; 60301 and its logfile will be at <code class="filename">logs/hbase-${USER}-1-regionserver-${HOSTNAME}.log</code>.
     			</p><p>To add 4 more regionservers in addition to the one you just started by running... </p><pre class="programlisting">% bin/local-regionservers.sh start 2 3 4 5</pre><p>
     			This supports up to 99 extra regionservers (100 total).
				</p></div><div class="section" title="1.2.2.1.1.2.&nbsp;Stop"><div class="titlepage"><div><div><h6 class="title"><a name="pseudo.options.stop"></a>1.2.2.1.1.2.&nbsp;Stop</h6></div></div></div><p>Assuming you want to stop master backup # 1, run...
            	</p><pre class="programlisting">% cat /tmp/hbase-${USER}-1-master.pid |xargs kill -9</pre><p>
            	Note that bin/local-master-backup.sh stop 1 will try to stop the cluster along with the master.
            	</p><p>To stop an individual regionserver, run...
                	</p><pre class="programlisting">% bin/local-regionservers.sh stop 1
	                </pre><p>
				</p></div></div></div><div class="section" title="1.2.2.2.&nbsp;Fully-distributed"><div class="titlepage"><div><div><h4 class="title"><a name="fully_dist"></a>1.2.2.2.&nbsp;Fully-distributed</h4></div></div></div><p>For running a fully-distributed operation on more than one
          host, make the following configurations. In
          <code class="filename">hbase-site.xml</code>, add the property
          <code class="varname">hbase.cluster.distributed</code> and set it to
          <code class="varname">true</code> and point the HBase
          <code class="varname">hbase.rootdir</code> at the appropriate HDFS NameNode
          and location in HDFS where you would like HBase to write data. For
          example, if you namenode were running at namenode.example.org on
          port 8020 and you wanted to home your HBase in HDFS at
          <code class="filename">/hbase</code>, make the following
          configuration.</p><pre class="programlisting">
&lt;configuration&gt;
  ...
  &lt;property&gt;
    &lt;name&gt;hbase.rootdir&lt;/name&gt;
    &lt;value&gt;hdfs://namenode.example.org:8020/hbase&lt;/value&gt;
    &lt;description&gt;The directory shared by RegionServers.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
    &lt;description&gt;The mode the cluster will be in. Possible values are
      false: standalone and pseudo-distributed setups with managed Zookeeper
      true: fully-distributed with unmanaged Zookeeper Quorum (see hbase-env.sh)
    &lt;/description&gt;
  &lt;/property&gt;
  ...
&lt;/configuration&gt;
</pre><div class="section" title="1.2.2.2.1.&nbsp;regionservers"><div class="titlepage"><div><div><h5 class="title"><a name="regionserver"></a>1.2.2.2.1.&nbsp;<code class="filename">regionservers</code></h5></div></div></div><p>In addition, a fully-distributed mode requires that you
            modify <code class="filename">conf/regionservers</code>. The
            <a class="xref" href="#regionservers" title="1.4.1.2.&nbsp;regionservers">Section&nbsp;1.4.1.2, &#8220;<code class="filename">regionservers</code>&#8221;</a> file
            lists all hosts that you would have running
            <span class="application">HRegionServer</span>s, one host per line (This
            file in HBase is like the Hadoop <code class="filename">slaves</code>
            file). All servers listed in this file will be started and stopped
            when HBase cluster start or stop is run.</p></div><div class="section" title="1.2.2.2.2.&nbsp;ZooKeeper and HBase"><div class="titlepage"><div><div><h5 class="title"><a name="hbase.zookeeper"></a>1.2.2.2.2.&nbsp;ZooKeeper and HBase</h5></div></div></div><p>See section <a class="xref" href="#">???</a> for ZooKeeper setup for HBase.</p></div><div class="section" title="1.2.2.2.3.&nbsp;HDFS Client Configuration"><div class="titlepage"><div><div><h5 class="title"><a name="hdfs_client_conf"></a>1.2.2.2.3.&nbsp;HDFS Client Configuration</h5></div></div></div><p>Of note, if you have made <span class="emphasis"><em>HDFS client
            configuration</em></span> on your Hadoop cluster -- i.e.
            configuration you want HDFS clients to use as opposed to
            server-side configurations -- HBase will not see this
            configuration unless you do one of the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Add a pointer to your <code class="varname">HADOOP_CONF_DIR</code>
                to the <code class="varname">HBASE_CLASSPATH</code> environment variable
                in <code class="filename">hbase-env.sh</code>.</p></li><li class="listitem"><p>Add a copy of <code class="filename">hdfs-site.xml</code> (or
                <code class="filename">hadoop-site.xml</code>) or, better, symlinks,
                under <code class="filename">${HBASE_HOME}/conf</code>, or</p></li><li class="listitem"><p>if only a small set of HDFS client configurations, add
                them to <code class="filename">hbase-site.xml</code>.</p></li></ul></div><p>An example of such an HDFS client configuration is
            <code class="varname">dfs.replication</code>. If for example, you want to
            run with a replication factor of 5, hbase will create files with
            the default of 3 unless you do the above to make the configuration
            available to HBase.</p></div></div></div><div class="section" title="1.2.3.&nbsp;Running and Confirming Your Installation"><div class="titlepage"><div><div><h3 class="title"><a name="confirm"></a>1.2.3.&nbsp;Running and Confirming Your Installation</h3></div></div></div><p>Make sure HDFS is running first. Start and stop the Hadoop HDFS
        daemons by running <code class="filename">bin/start-hdfs.sh</code> over in the
        <code class="varname">HADOOP_HOME</code> directory. You can ensure it started
        properly by testing the <span class="command"><strong>put</strong></span> and
        <span class="command"><strong>get</strong></span> of files into the Hadoop filesystem. HBase does
        not normally use the mapreduce daemons. These do not need to be
        started.</p><p><span class="emphasis"><em>If</em></span> you are managing your own ZooKeeper,
        start it and confirm its running else, HBase will start up ZooKeeper
        for you as part of its start process.</p><p>Start HBase with the following command:</p><pre class="programlisting">bin/start-hbase.sh</pre>

         Run the above from the

        <code class="varname">HBASE_HOME</code>

         directory.

        <p>You should now have a running HBase instance. HBase logs can be
        found in the <code class="filename">logs</code> subdirectory. Check them out
        especially if HBase had trouble starting.</p><p>HBase also puts up a UI listing vital attributes. By default its
        deployed on the Master host at port 60010 (HBase RegionServers listen
        on port 60020 by default and put up an informational http server at
        60030). If the Master were running on a host named
        <code class="varname">master.example.org</code> on the default port, to see the
        Master's homepage you'd point your browser at
        <code class="filename">http://master.example.org:60010</code>.</p><p>Once HBase has started, see the <a class="xref" href="#">???</a> for how to
        create tables, add data, scan your insertions, and finally disable and
        drop your tables.</p><p>To stop HBase after exiting the HBase shell enter
        </p><pre class="programlisting">$ ./bin/stop-hbase.sh
stopping hbase...............</pre><p> Shutdown can take a moment to
        complete. It can take longer if your cluster is comprised of many
        machines. If you are running a distributed operation, be sure to wait
        until HBase has shut down completely before stopping the Hadoop
        daemons.</p></div></div><div class="section" title="1.3.&nbsp;Configuration Files"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="config.files"></a>1.3.&nbsp;Configuration Files</h2></div></div></div><div class="section" title="1.3.1.&nbsp;hbase-site.xml and hbase-default.xml"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.site"></a>1.3.1.&nbsp;<code class="filename">hbase-site.xml</code> and <code class="filename">hbase-default.xml</code></h3></div></div></div><p>Just as in Hadoop where you add site-specific HDFS configuration
    to the <code class="filename">hdfs-site.xml</code> file,
    for HBase, site specific customizations go into
    the file <code class="filename">conf/hbase-site.xml</code>.
    For the list of configurable properties, see
    <a class="xref" href="#hbase_default_configurations" title="1.3.1.1.&nbsp;HBase Default Configuration">Section&nbsp;1.3.1.1, &#8220;HBase Default Configuration&#8221;</a>
    below or view the raw <code class="filename">hbase-default.xml</code>
    source file in the HBase source code at
    <code class="filename">src/main/resources</code>.
    </p><p>
    Not all configuration options make it out to
    <code class="filename">hbase-default.xml</code>.  Configuration
    that it is thought rare anyone would change can exist only
    in code; the only way to turn up such configurations is
    via a reading of the source code itself.
    </p><p>
      Currently, changes here will require a cluster restart for HBase to notice the change.
      </p><div class="section" title="1.3.1.1.&nbsp;HBase Default Configuration"><div class="titlepage"><div><div><h4 class="title"><a name="hbase_default_configurations"></a>1.3.1.1.&nbsp;HBase Default Configuration</h4></div></div></div><p></p><div class="glossary" title="HBase Default Configuration"><div class="titlepage"><div><div><h5 class="title"><a name="hbase.default.configuration"></a>HBase Default Configuration</h5></div></div></div><p>
The documentation below is generated using the default hbase configuration file,
<code class="filename">hbase-default.xml</code>, as source.
</p><dl><dt><a name="hbase.tmp.dir"></a><code class="varname">hbase.tmp.dir</code></dt><dd><p>Temporary directory on the local filesystem.
    Change this setting to point to a location more permanent
    than '/tmp', the usual resolve for java.io.tmpdir, as the
    '/tmp' directory is cleared on machine restart.</p><p>Default: <code class="varname">${java.io.tmpdir}/hbase-${user.name}</code></p></dd><dt><a name="hbase.rootdir"></a><code class="varname">hbase.rootdir</code></dt><dd><p>The directory shared by region servers and into
    which HBase persists.  The URL should be 'fully-qualified'
    to include the filesystem scheme.  For example, to specify the
    HDFS directory '/hbase' where the HDFS instance's namenode is
    running at namenode.example.org on port 9000, set this value to:
    hdfs://namenode.example.org:9000/hbase.  By default, we write
    to whatever ${hbase.tmp.dir} is set too -- usually /tmp --
    so change this configuration or else all data will be lost on
    machine restart.</p><p>Default: <code class="varname">${hbase.tmp.dir}/hbase</code></p></dd><dt><a name="hbase.cluster.distributed"></a><code class="varname">hbase.cluster.distributed</code></dt><dd><p>The mode the cluster will be in. Possible values are
      false for standalone mode and true for distributed mode.  If
      false, startup will run all HBase and ZooKeeper daemons together
      in the one JVM.</p><p>Default: <code class="varname">false</code></p></dd><dt><a name="hbase.zookeeper.quorum"></a><code class="varname">hbase.zookeeper.quorum</code></dt><dd><p>Comma separated list of servers in the ZooKeeper ensemble
    (This config. should have been named hbase.zookeeper.ensemble).
    For example, "host1.mydomain.com,host2.mydomain.com,host3.mydomain.com".
    By default this is set to localhost for local and pseudo-distributed modes
    of operation. For a fully-distributed setup, this should be set to a full
    list of ZooKeeper ensemble servers. If HBASE_MANAGES_ZK is set in hbase-env.sh
    this is the list of servers which hbase will start/stop ZooKeeper on as
    part of cluster start/stop.  Client-side, we will take this list of
    ensemble members and put it together with the hbase.zookeeper.clientPort
    config. and pass it into zookeeper constructor as the connectString
    parameter.</p><p>Default: <code class="varname">localhost</code></p></dd><dt><a name="hbase.local.dir"></a><code class="varname">hbase.local.dir</code></dt><dd><p>Directory on the local filesystem to be used
    as a local storage.</p><p>Default: <code class="varname">${hbase.tmp.dir}/local/</code></p></dd><dt><a name="hbase.master.port"></a><code class="varname">hbase.master.port</code></dt><dd><p>The port the HBase Master should bind to.</p><p>Default: <code class="varname">60000</code></p></dd><dt><a name="hbase.master.info.port"></a><code class="varname">hbase.master.info.port</code></dt><dd><p>The port for the HBase Master web UI.
    Set to -1 if you do not want a UI instance run.</p><p>Default: <code class="varname">60010</code></p></dd><dt><a name="hbase.master.info.bindAddress"></a><code class="varname">hbase.master.info.bindAddress</code></dt><dd><p>The bind address for the HBase Master web UI
    </p><p>Default: <code class="varname">0.0.0.0</code></p></dd><dt><a name="hbase.master.logcleaner.plugins"></a><code class="varname">hbase.master.logcleaner.plugins</code></dt><dd><p>A comma-separated list of LogCleanerDelegate invoked by
    the LogsCleaner service. These WAL/HLog cleaners are called in order,
    so put the HLog cleaner that prunes the most HLog files in front. To
    implement your own LogCleanerDelegate, just put it in HBase's classpath
    and add the fully qualified class name here. Always add the above
    default log cleaners in the list.</p><p>Default: <code class="varname">org.apache.hadoop.hbase.master.cleaner.TimeToLiveLogCleaner</code></p></dd><dt><a name="hbase.master.logcleaner.ttl"></a><code class="varname">hbase.master.logcleaner.ttl</code></dt><dd><p>Maximum time a HLog can stay in the .oldlogdir directory,
    after which it will be cleaned by a Master thread.</p><p>Default: <code class="varname">600000</code></p></dd><dt><a name="hbase.master.hfilecleaner.plugins"></a><code class="varname">hbase.master.hfilecleaner.plugins</code></dt><dd><p>A comma-separated list of HFileCleanerDelegate invoked by
    the HFileCleaner service. These HFiles cleaners are called in order,
    so put the cleaner that prunes the most files in front. To
    implement your own HFileCleanerDelegate, just put it in HBase's classpath
    and add the fully qualified class name here. Always add the above
    default log cleaners in the list as they will be overwritten in
    hbase-site.xml.</p><p>Default: <code class="varname">org.apache.hadoop.hbase.master.cleaner.TimeToLiveHFileCleaner</code></p></dd><dt><a name="hbase.master.catalog.timeout"></a><code class="varname">hbase.master.catalog.timeout</code></dt><dd><p>Timeout value for the Catalog Janitor from the master to
    META.</p><p>Default: <code class="varname">600000</code></p></dd><dt><a name="fail.fast.expired.active.master"></a><code class="varname">fail.fast.expired.active.master</code></dt><dd><p>If abort immediately for the expired master without trying
      to recover its zk session.</p><p>Default: <code class="varname">false</code></p></dd><dt><a name="hbase.master.dns.interface"></a><code class="varname">hbase.master.dns.interface</code></dt><dd><p>The name of the Network Interface from which a master
      should report its IP address.</p><p>Default: <code class="varname">default</code></p></dd><dt><a name="hbase.master.dns.nameserver"></a><code class="varname">hbase.master.dns.nameserver</code></dt><dd><p>The host name or IP address of the name server (DNS)
      which a master should use to determine the host name used
      for communication and display purposes.</p><p>Default: <code class="varname">default</code></p></dd><dt><a name="hbase.regionserver.port"></a><code class="varname">hbase.regionserver.port</code></dt><dd><p>The port the HBase RegionServer binds to.</p><p>Default: <code class="varname">60020</code></p></dd><dt><a name="hbase.regionserver.info.port"></a><code class="varname">hbase.regionserver.info.port</code></dt><dd><p>The port for the HBase RegionServer web UI
    Set to -1 if you do not want the RegionServer UI to run.</p><p>Default: <code class="varname">60030</code></p></dd><dt><a name="hbase.regionserver.info.bindAddress"></a><code class="varname">hbase.regionserver.info.bindAddress</code></dt><dd><p>The address for the HBase RegionServer web UI</p><p>Default: <code class="varname">0.0.0.0</code></p></dd><dt><a name="hbase.regionserver.info.port.auto"></a><code class="varname">hbase.regionserver.info.port.auto</code></dt><dd><p>Whether or not the Master or RegionServer
    UI should search for a port to bind to. Enables automatic port
    search if hbase.regionserver.info.port is already in use.
    Useful for testing, turned off by default.</p><p>Default: <code class="varname">false</code></p></dd><dt><a name="hbase.regionserver.handler.count"></a><code class="varname">hbase.regionserver.handler.count</code></dt><dd><p>Count of RPC Listener instances spun up on RegionServers.
    Same property is used by the Master for count of master handlers.</p><p>Default: <code class="varname">30</code></p></dd><dt><a name="hbase.regionserver.msginterval"></a><code class="varname">hbase.regionserver.msginterval</code></dt><dd><p>Interval between messages from the RegionServer to Master
    in milliseconds.</p><p>Default: <code class="varname">3000</code></p></dd><dt><a name="hbase.regionserver.optionallogflushinterval"></a><code class="varname">hbase.regionserver.optionallogflushinterval</code></dt><dd><p>Sync the HLog to the HDFS after this interval if it has not
    accumulated enough entries to trigger a sync. Units: milliseconds.</p><p>Default: <code class="varname">1000</code></p></dd><dt><a name="hbase.regionserver.regionSplitLimit"></a><code class="varname">hbase.regionserver.regionSplitLimit</code></dt><dd><p>Limit for the number of regions after which no more region
    splitting should take place. This is not a hard limit for the number of
    regions but acts as a guideline for the regionserver to stop splitting after
    a certain limit. Default is MAX_INT; i.e. do not block splitting.</p><p>Default: <code class="varname">2147483647</code></p></dd><dt><a name="hbase.regionserver.logroll.period"></a><code class="varname">hbase.regionserver.logroll.period</code></dt><dd><p>Period at which we will roll the commit log regardless
    of how many edits it has.</p><p>Default: <code class="varname">3600000</code></p></dd><dt><a name="hbase.regionserver.logroll.errors.tolerated"></a><code class="varname">hbase.regionserver.logroll.errors.tolerated</code></dt><dd><p>The number of consecutive WAL close errors we will allow
    before triggering a server abort.  A setting of 0 will cause the
    region server to abort if closing the current WAL writer fails during
    log rolling.  Even a small value (2 or 3) will allow a region server
    to ride over transient HDFS errors.</p><p>Default: <code class="varname">2</code></p></dd><dt><a name="hbase.regionserver.hlog.reader.impl"></a><code class="varname">hbase.regionserver.hlog.reader.impl</code></dt><dd><p>The HLog file reader implementation.</p><p>Default: <code class="varname">org.apache.hadoop.hbase.regionserver.wal.ProtobufLogReader</code></p></dd><dt><a name="hbase.regionserver.hlog.writer.impl"></a><code class="varname">hbase.regionserver.hlog.writer.impl</code></dt><dd><p>The HLog file writer implementation.</p><p>Default: <code class="varname">org.apache.hadoop.hbase.regionserver.wal.ProtobufLogWriter</code></p></dd><dt><a name="hbase.regionserver.global.memstore.upperLimit"></a><code class="varname">hbase.regionserver.global.memstore.upperLimit</code></dt><dd><p>Maximum size of all memstores in a region server before new
      updates are blocked and flushes are forced. Defaults to 40% of heap.
      Updates are blocked and flushes are forced until size of all memstores
      in a region server hits hbase.regionserver.global.memstore.lowerLimit.</p><p>Default: <code class="varname">0.4</code></p></dd><dt><a name="hbase.regionserver.global.memstore.lowerLimit"></a><code class="varname">hbase.regionserver.global.memstore.lowerLimit</code></dt><dd><p>Maximum size of all memstores in a region server before
      flushes are forced. Defaults to 38% of heap.
      This value equal to hbase.regionserver.global.memstore.upperLimit causes
      the minimum possible flushing to occur when updates are blocked due to
      memstore limiting.</p><p>Default: <code class="varname">0.38</code></p></dd><dt><a name="hbase.regionserver.optionalcacheflushinterval"></a><code class="varname">hbase.regionserver.optionalcacheflushinterval</code></dt><dd><p>
    Maximum amount of time an edit lives in memory before being automatically flushed.
    Default 1 hour. Set it to 0 to disable automatic flushing.</p><p>Default: <code class="varname">3600000</code></p></dd><dt><a name="hbase.regionserver.catalog.timeout"></a><code class="varname">hbase.regionserver.catalog.timeout</code></dt><dd><p>Timeout value for the Catalog Janitor from the regionserver to META.</p><p>Default: <code class="varname">600000</code></p></dd><dt><a name="hbase.regionserver.dns.interface"></a><code class="varname">hbase.regionserver.dns.interface</code></dt><dd><p>The name of the Network Interface from which a region server
      should report its IP address.</p><p>Default: <code class="varname">default</code></p></dd><dt><a name="hbase.regionserver.dns.nameserver"></a><code class="varname">hbase.regionserver.dns.nameserver</code></dt><dd><p>The host name or IP address of the name server (DNS)
      which a region server should use to determine the host name used by the
      master for communication and display purposes.</p><p>Default: <code class="varname">default</code></p></dd><dt><a name="zookeeper.session.timeout"></a><code class="varname">zookeeper.session.timeout</code></dt><dd><p>ZooKeeper session timeout in milliseconds. It is used in two different ways.
      First, this value is used in the ZK client that HBase uses to connect to the ensemble.
      It is also used by HBase when it starts a ZK server and it is passed as the 'maxSessionTimeout'. See
      http://hadoop.apache.org/zookeeper/docs/current/zookeeperProgrammers.html#ch_zkSessions.
      For example, if a HBase region server connects to a ZK ensemble that's also managed by HBase, then the
      session timeout will be the one specified by this configuration. But, a region server that connects
      to an ensemble managed with a different configuration will be subjected that ensemble's maxSessionTimeout. So,
      even though HBase might propose using 90 seconds, the ensemble can have a max timeout lower than this and
      it will take precedence. The current default that ZK ships with is 40 seconds, which is lower than HBase's.
    </p><p>Default: <code class="varname">90000</code></p></dd><dt><a name="zookeeper.znode.parent"></a><code class="varname">zookeeper.znode.parent</code></dt><dd><p>Root ZNode for HBase in ZooKeeper. All of HBase's ZooKeeper
      files that are configured with a relative path will go under this node.
      By default, all of HBase's ZooKeeper file path are configured with a
      relative path, so they will all go under this directory unless changed.</p><p>Default: <code class="varname">/hbase</code></p></dd><dt><a name="zookeeper.znode.rootserver"></a><code class="varname">zookeeper.znode.rootserver</code></dt><dd><p>Path to ZNode holding root region location. This is written by
      the master and read by clients and region servers. If a relative path is
      given, the parent folder will be ${zookeeper.znode.parent}. By default,
      this means the root location is stored at /hbase/root-region-server.</p><p>Default: <code class="varname">root-region-server</code></p></dd><dt><a name="zookeeper.znode.acl.parent"></a><code class="varname">zookeeper.znode.acl.parent</code></dt><dd><p>Root ZNode for access control lists.</p><p>Default: <code class="varname">acl</code></p></dd><dt><a name="hbase.zookeeper.dns.interface"></a><code class="varname">hbase.zookeeper.dns.interface</code></dt><dd><p>The name of the Network Interface from which a ZooKeeper server
      should report its IP address.</p><p>Default: <code class="varname">default</code></p></dd><dt><a name="hbase.zookeeper.dns.nameserver"></a><code class="varname">hbase.zookeeper.dns.nameserver</code></dt><dd><p>The host name or IP address of the name server (DNS)
      which a ZooKeeper server should use to determine the host name used by the
      master for communication and display purposes.</p><p>Default: <code class="varname">default</code></p></dd><dt><a name="hbase.zookeeper.peerport"></a><code class="varname">hbase.zookeeper.peerport</code></dt><dd><p>Port used by ZooKeeper peers to talk to each other.
    Seehttp://hadoop.apache.org/zookeeper/docs/r3.1.1/zookeeperStarted.html#sc_RunningReplicatedZooKeeper
    for more information.</p><p>Default: <code class="varname">2888</code></p></dd><dt><a name="hbase.zookeeper.leaderport"></a><code class="varname">hbase.zookeeper.leaderport</code></dt><dd><p>Port used by ZooKeeper for leader election.
    See http://hadoop.apache.org/zookeeper/docs/r3.1.1/zookeeperStarted.html#sc_RunningReplicatedZooKeeper
    for more information.</p><p>Default: <code class="varname">3888</code></p></dd><dt><a name="hbase.zookeeper.useMulti"></a><code class="varname">hbase.zookeeper.useMulti</code></dt><dd><p>Instructs HBase to make use of ZooKeeper's multi-update functionality.
    This allows certain ZooKeeper operations to complete more quickly and prevents some issues
    with rare Replication failure scenarios (see the release note of HBASE-2611 for an example).
    IMPORTANT: only set this to true if all ZooKeeper servers in the cluster are on version 3.4+
    and will not be downgraded.  ZooKeeper versions before 3.4 do not support multi-update and
    will not fail gracefully if multi-update is invoked (see ZOOKEEPER-1495).</p><p>Default: <code class="varname">false</code></p></dd><dt><a name="hbase.config.read.zookeeper.config"></a><code class="varname">hbase.config.read.zookeeper.config</code></dt><dd><p>
        Set to true to allow HBaseConfiguration to read the
        zoo.cfg file for ZooKeeper properties. Switching this to true
        is not recommended, since the functionality of reading ZK
        properties from a zoo.cfg file has been deprecated.</p><p>Default: <code class="varname">false</code></p></dd><dt><a name="hbase.zookeeper.property.initLimit"></a><code class="varname">hbase.zookeeper.property.initLimit</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    The number of ticks that the initial synchronization phase can take.</p><p>Default: <code class="varname">10</code></p></dd><dt><a name="hbase.zookeeper.property.syncLimit"></a><code class="varname">hbase.zookeeper.property.syncLimit</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    The number of ticks that can pass between sending a request and getting an
    acknowledgment.</p><p>Default: <code class="varname">5</code></p></dd><dt><a name="hbase.zookeeper.property.dataDir"></a><code class="varname">hbase.zookeeper.property.dataDir</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    The directory where the snapshot is stored.</p><p>Default: <code class="varname">${hbase.tmp.dir}/zookeeper</code></p></dd><dt><a name="hbase.zookeeper.property.clientPort"></a><code class="varname">hbase.zookeeper.property.clientPort</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    The port at which the clients will connect.</p><p>Default: <code class="varname">2181</code></p></dd><dt><a name="hbase.zookeeper.property.maxClientCnxns"></a><code class="varname">hbase.zookeeper.property.maxClientCnxns</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    Limit on number of concurrent connections (at the socket level) that a
    single client, identified by IP address, may make to a single member of
    the ZooKeeper ensemble. Set high to avoid zk connection issues running
    standalone and pseudo-distributed.</p><p>Default: <code class="varname">300</code></p></dd><dt><a name="hbase.client.write.buffer"></a><code class="varname">hbase.client.write.buffer</code></dt><dd><p>Default size of the HTable client write buffer in bytes.
    A bigger buffer takes more memory -- on both the client and server
    side since server instantiates the passed write buffer to process
    it -- but a larger buffer size reduces the number of RPCs made.
    For an estimate of server-side memory-used, evaluate
    hbase.client.write.buffer * hbase.regionserver.handler.count</p><p>Default: <code class="varname">2097152</code></p></dd><dt><a name="hbase.client.pause"></a><code class="varname">hbase.client.pause</code></dt><dd><p>General client pause value.  Used mostly as value to wait
    before running a retry of a failed get, region lookup, etc.
    See hbase.client.retries.number for description of how we backoff from
    this initial pause amount and how this pause works w/ retries.</p><p>Default: <code class="varname">100</code></p></dd><dt><a name="hbase.client.retries.number"></a><code class="varname">hbase.client.retries.number</code></dt><dd><p>Maximum retries.  Used as maximum for all retryable
    operations such as the getting of a cell's value, starting a row update,
    etc.  Retry interval is a rough function based on hbase.client.pause.  At
    first we retry at this interval but then with backoff, we pretty quickly reach
    retrying every ten seconds.  See HConstants#RETRY_BACKOFF for how the backup
    ramps up.  Change this setting and hbase.client.pause to suit your workload.</p><p>Default: <code class="varname">35</code></p></dd><dt><a name="hbase.client.max.total.tasks"></a><code class="varname">hbase.client.max.total.tasks</code></dt><dd><p>The maximum number of concurrent tasks a single HTable instance will
    send to the cluster.</p><p>Default: <code class="varname">100</code></p></dd><dt><a name="hbase.client.max.perserver.tasks"></a><code class="varname">hbase.client.max.perserver.tasks</code></dt><dd><p>The maximum number of concurrent tasks a single HTable instance will
    send to a single region server.</p><p>Default: <code class="varname">5</code></p></dd><dt><a name="hbase.client.max.perregion.tasks"></a><code class="varname">hbase.client.max.perregion.tasks</code></dt><dd><p>The maximum number of concurrent connections the client will
    maintain to a single Region. That is, if there is already
    hbase.client.max.perregion.tasks writes in progress for this region, new puts
    won't be sent to this region until some writes finishes.</p><p>Default: <code class="varname">1</code></p></dd><dt><a name="hbase.client.scanner.caching"></a><code class="varname">hbase.client.scanner.caching</code></dt><dd><p>Number of rows that will be fetched when calling next
    on a scanner if it is not served from (local, client) memory. Higher
    caching values will enable faster scanners but will eat up more memory
    and some calls of next may take longer and longer times when the cache is empty.
    Do not set this value such that the time between invocations is greater
    than the scanner timeout; i.e. hbase.client.scanner.timeout.period</p><p>Default: <code class="varname">100</code></p></dd><dt><a name="hbase.client.keyvalue.maxsize"></a><code class="varname">hbase.client.keyvalue.maxsize</code></dt><dd><p>Specifies the combined maximum allowed size of a KeyValue
    instance. This is to set an upper boundary for a single entry saved in a
    storage file. Since they cannot be split it helps avoiding that a region
    cannot be split any further because the data is too large. It seems wise
    to set this to a fraction of the maximum region size. Setting it to zero
    or less disables the check.</p><p>Default: <code class="varname">10485760</code></p></dd><dt><a name="hbase.client.scanner.timeout.period"></a><code class="varname">hbase.client.scanner.timeout.period</code></dt><dd><p>Client scanner lease period in milliseconds.</p><p>Default: <code class="varname">60000</code></p></dd><dt><a name="hbase.client.localityCheck.threadPoolSize"></a><code class="varname">hbase.client.localityCheck.threadPoolSize</code></dt><dd><p></p><p>Default: <code class="varname">2</code></p></dd><dt><a name="hbase.bulkload.retries.number"></a><code class="varname">hbase.bulkload.retries.number</code></dt><dd><p>Maximum retries.  This is maximum number of iterations
    to atomic bulk loads are attempted in the face of splitting operations
    0 means never give up.</p><p>Default: <code class="varname">0</code></p></dd><dt><a name="hbase.balancer.period%0A    "></a><code class="varname">hbase.balancer.period
    </code></dt><dd><p>Period at which the region balancer runs in the Master.</p><p>Default: <code class="varname">300000</code></p></dd><dt><a name="hbase.regions.slop"></a><code class="varname">hbase.regions.slop</code></dt><dd><p>Rebalance if any regionserver has average + (average * slop) regions.</p><p>Default: <code class="varname">0.2</code></p></dd><dt><a name="hbase.server.thread.wakefrequency"></a><code class="varname">hbase.server.thread.wakefrequency</code></dt><dd><p>Time to sleep in between searches for work (in milliseconds).
    Used as sleep interval by service threads such as log roller.</p><p>Default: <code class="varname">10000</code></p></dd><dt><a name="hbase.server.versionfile.writeattempts"></a><code class="varname">hbase.server.versionfile.writeattempts</code></dt><dd><p>
    How many time to retry attempting to write a version file
    before just aborting. Each attempt is seperated by the
    hbase.server.thread.wakefrequency milliseconds.</p><p>Default: <code class="varname">3</code></p></dd><dt><a name="hbase.hregion.memstore.flush.size"></a><code class="varname">hbase.hregion.memstore.flush.size</code></dt><dd><p>
    Memstore will be flushed to disk if size of the memstore
    exceeds this number of bytes.  Value is checked by a thread that runs
    every hbase.server.thread.wakefrequency.</p><p>Default: <code class="varname">134217728</code></p></dd><dt><a name="hbase.hregion.preclose.flush.size"></a><code class="varname">hbase.hregion.preclose.flush.size</code></dt><dd><p>
      If the memstores in a region are this size or larger when we go
      to close, run a "pre-flush" to clear out memstores before we put up
      the region closed flag and take the region offline.  On close,
      a flush is run under the close flag to empty memory.  During
      this time the region is offline and we are not taking on any writes.
      If the memstore content is large, this flush could take a long time to
      complete.  The preflush is meant to clean out the bulk of the memstore
      before putting up the close flag and taking the region offline so the
      flush that runs under the close flag has little to do.</p><p>Default: <code class="varname">5242880</code></p></dd><dt><a name="hbase.hregion.memstore.block.multiplier"></a><code class="varname">hbase.hregion.memstore.block.multiplier</code></dt><dd><p>
    Block updates if memstore has hbase.hregion.block.memstore
    time hbase.hregion.flush.size bytes.  Useful preventing
    runaway memstore during spikes in update traffic.  Without an
    upper-bound, memstore fills such that when it flushes the
    resultant flush files take a long time to compact or split, or
    worse, we OOME.</p><p>Default: <code class="varname">2</code></p></dd><dt><a name="hbase.hregion.memstore.mslab.enabled"></a><code class="varname">hbase.hregion.memstore.mslab.enabled</code></dt><dd><p>
      Enables the MemStore-Local Allocation Buffer,
      a feature which works to prevent heap fragmentation under
      heavy write loads. This can reduce the frequency of stop-the-world
      GC pauses on large heaps.</p><p>Default: <code class="varname">true</code></p></dd><dt><a name="hbase.hregion.max.filesize"></a><code class="varname">hbase.hregion.max.filesize</code></dt><dd><p>
    Maximum HStoreFile size. If any one of a column families' HStoreFiles has
    grown to exceed this value, the hosting HRegion is split in two.</p><p>Default: <code class="varname">10737418240</code></p></dd><dt><a name="hbase.hregion.majorcompaction"></a><code class="varname">hbase.hregion.majorcompaction</code></dt><dd><p>The time (in miliseconds) between 'major' compactions of all
    HStoreFiles in a region.  Default: Set to 7 days.  Major compactions tend to
    happen exactly when you need them least so enable them such that they run at
    off-peak for your deploy; or, since this setting is on a periodicity that is
    unlikely to match your loading, run the compactions via an external
    invocation out of a cron job or some such.</p><p>Default: <code class="varname">604800000</code></p></dd><dt><a name="hbase.hregion.majorcompaction.jitter"></a><code class="varname">hbase.hregion.majorcompaction.jitter</code></dt><dd><p>Jitter outer bound for major compactions.
    On each regionserver, we multiply the hbase.region.majorcompaction
    interval by some random fraction that is inside the bounds of this
    maximum.  We then add this + or - product to when the next
    major compaction is to run.  The idea is that major compaction
    does happen on every regionserver at exactly the same time.  The
    smaller this number, the closer the compactions come together.</p><p>Default: <code class="varname">0.50</code></p></dd><dt><a name="hbase.hstore.compactionThreshold"></a><code class="varname">hbase.hstore.compactionThreshold</code></dt><dd><p>
    If more than this number of HStoreFiles in any one HStore
    (one HStoreFile is written per flush of memstore) then a compaction
    is run to rewrite all HStoreFiles files as one.  Larger numbers
    put off compaction but when it runs, it takes longer to complete.</p><p>Default: <code class="varname">3</code></p></dd><dt><a name="hbase.hstore.blockingStoreFiles"></a><code class="varname">hbase.hstore.blockingStoreFiles</code></dt><dd><p>
    If more than this number of StoreFiles in any one Store
    (one StoreFile is written per flush of MemStore) then updates are
    blocked for this HRegion until a compaction is completed, or
    until hbase.hstore.blockingWaitTime has been exceeded.</p><p>Default: <code class="varname">10</code></p></dd><dt><a name="hbase.hstore.blockingWaitTime"></a><code class="varname">hbase.hstore.blockingWaitTime</code></dt><dd><p>
    The time an HRegion will block updates for after hitting the StoreFile
    limit defined by hbase.hstore.blockingStoreFiles.
    After this time has elapsed, the HRegion will stop blocking updates even
    if a compaction has not been completed.</p><p>Default: <code class="varname">90000</code></p></dd><dt><a name="hbase.hstore.compaction.max"></a><code class="varname">hbase.hstore.compaction.max</code></dt><dd><p>Max number of HStoreFiles to compact per 'minor' compaction.</p><p>Default: <code class="varname">10</code></p></dd><dt><a name="hbase.hstore.compaction.kv.max"></a><code class="varname">hbase.hstore.compaction.kv.max</code></dt><dd><p>How many KeyValues to read and then write in a batch when flushing
        or compacting.  Do less if big KeyValues and problems with OOME.
        Do more if wide, small rows.</p><p>Default: <code class="varname">10</code></p></dd><dt><a name="hbase.storescanner.parallel.seek.enable"></a><code class="varname">hbase.storescanner.parallel.seek.enable</code></dt><dd><p>
      Enables StoreFileScanner parallel-seeking in StoreScanner,
      a feature which can reduce response latency under special conditions.</p><p>Default: <code class="varname">false</code></p></dd><dt><a name="hbase.storescanner.parallel.seek.threads"></a><code class="varname">hbase.storescanner.parallel.seek.threads</code></dt><dd><p>
      The default thread pool size if parallel-seeking feature enabled.</p><p>Default: <code class="varname">10</code></p></dd><dt><a name="hfile.block.cache.size"></a><code class="varname">hfile.block.cache.size</code></dt><dd><p>Percentage of maximum heap (-Xmx setting) to allocate to block cache
        used by HFile/StoreFile. Default of 0.4 means allocate 40%.
        Set to 0 to disable but it's not recommended; you need at least
        enough cache to hold the storefile indices.</p><p>Default: <code class="varname">0.4</code></p></dd><dt><a name="hfile.block.index.cacheonwrite"></a><code class="varname">hfile.block.index.cacheonwrite</code></dt><dd><p>This allows to put non-root multi-level index blocks into the block
          cache at the time the index is being written.</p><p>Default: <code class="varname">false</code></p></dd><dt><a name="hfile.index.block.max.size"></a><code class="varname">hfile.index.block.max.size</code></dt><dd><p>When the size of a leaf-level, intermediate-level, or root-level
          index block in a multi-level block index grows to this size, the
          block is written out and a new block is started.</p><p>Default: <code class="varname">131072</code></p></dd><dt><a name="hfile.format.version"></a><code class="varname">hfile.format.version</code></dt><dd><p>The HFile format version to use for new files. Set this to 1 to test
          backwards-compatibility. The default value of this option should be
          consistent with FixedFileTrailer.MAX_VERSION.</p><p>Default: <code class="varname">2</code></p></dd><dt><a name="hfile.block.bloom.cacheonwrite"></a><code class="varname">hfile.block.bloom.cacheonwrite</code></dt><dd><p>Enables cache-on-write for inline blocks of a compound Bloom filter.</p><p>Default: <code class="varname">false</code></p></dd><dt><a name="io.storefile.bloom.block.size"></a><code class="varname">io.storefile.bloom.block.size</code></dt><dd><p>The size in bytes of a single block ("chunk") of a compound Bloom
          filter. This size is approximate, because Bloom blocks can only be
          inserted at data block boundaries, and the number of keys per data
          block varies.</p><p>Default: <code class="varname">131072</code></p></dd><dt><a name="hbase.rs.cacheblocksonwrite"></a><code class="varname">hbase.rs.cacheblocksonwrite</code></dt><dd><p>Whether an HFile block should be added to the block cache when the
          block is finished.</p><p>Default: <code class="varname">false</code></p></dd><dt><a name="hbase.rpc.server.engine"></a><code class="varname">hbase.rpc.server.engine</code></dt><dd><p>Implementation of org.apache.hadoop.hbase.ipc.RpcServerEngine to be
    used for server RPC call marshalling.</p><p>Default: <code class="varname">org.apache.hadoop.hbase.ipc.ProtobufRpcServerEngine</code></p></dd><dt><a name="hbase.rpc.timeout"></a><code class="varname">hbase.rpc.timeout</code></dt><dd><p>This is for the RPC layer to define how long HBase client applications
        take for a remote call to time out. It uses pings to check connections
        but will eventually throw a TimeoutException.</p><p>Default: <code class="varname">60000</code></p></dd><dt><a name="hbase.rpc.shortoperation.timeout"></a><code class="varname">hbase.rpc.shortoperation.timeout</code></dt><dd><p>This is another version of "hbase.rpc.timeout". For those RPC operation
        within cluster, we rely on this configuration to set a short timeout limitation
        for short operation. For example, short rpc timeout for region server's trying
        to report to active master can benefit quicker master failover process.</p><p>Default: <code class="varname">10000</code></p></dd><dt><a name="hbase.ipc.client.tcpnodelay"></a><code class="varname">hbase.ipc.client.tcpnodelay</code></dt><dd><p>Set no delay on rpc socket connections.  See
    http://docs.oracle.com/javase/1.5.0/docs/api/java/net/Socket.html#getTcpNoDelay()</p><p>Default: <code class="varname">true</code></p></dd><dt><a name="hbase.master.keytab.file"></a><code class="varname">hbase.master.keytab.file</code></dt><dd><p>Full path to the kerberos keytab file to use for logging in
    the configured HMaster server principal.</p><p>Default: <code class="varname"></code></p></dd><dt><a name="hbase.master.kerberos.principal"></a><code class="varname">hbase.master.kerberos.principal</code></dt><dd><p>Ex. "hbase/_HOST@EXAMPLE.COM".  The kerberos principal name
    that should be used to run the HMaster process.  The principal name should
    be in the form: user/hostname@DOMAIN.  If "_HOST" is used as the hostname
    portion, it will be replaced with the actual hostname of the running
    instance.</p><p>Default: <code class="varname"></code></p></dd><dt><a name="hbase.regionserver.keytab.file"></a><code class="varname">hbase.regionserver.keytab.file</code></dt><dd><p>Full path to the kerberos keytab file to use for logging in
    the configured HRegionServer server principal.</p><p>Default: <code class="varname"></code></p></dd><dt><a name="hbase.regionserver.kerberos.principal"></a><code class="varname">hbase.regionserver.kerberos.principal</code></dt><dd><p>Ex. "hbase/_HOST@EXAMPLE.COM".  The kerberos principal name
    that should be used to run the HRegionServer process.  The principal name
    should be in the form: user/hostname@DOMAIN.  If "_HOST" is used as the
    hostname portion, it will be replaced with the actual hostname of the
    running instance.  An entry for this principal must exist in the file
    specified in hbase.regionserver.keytab.file</p><p>Default: <code class="varname"></code></p></dd><dt><a name="hadoop.policy.file"></a><code class="varname">hadoop.policy.file</code></dt><dd><p>The policy configuration file used by RPC servers to make
      authorization decisions on client requests.  Only used when HBase
      security is enabled.</p><p>Default: <code class="varname">hbase-policy.xml</code></p></dd><dt><a name="hbase.superuser"></a><code class="varname">hbase.superuser</code></dt><dd><p>List of users or groups (comma-separated), who are allowed
    full privileges, regardless of stored ACLs, across the cluster.
    Only used when HBase security is enabled.</p><p>Default: <code class="varname"></code></p></dd><dt><a name="hbase.auth.key.update.interval"></a><code class="varname">hbase.auth.key.update.interval</code></dt><dd><p>The update interval for master key for authentication tokens
    in servers in milliseconds.  Only used when HBase security is enabled.</p><p>Default: <code class="varname">86400000</code></p></dd><dt><a name="hbase.auth.token.max.lifetime"></a><code class="varname">hbase.auth.token.max.lifetime</code></dt><dd><p>The maximum lifetime in milliseconds after which an
    authentication token expires.  Only used when HBase security is enabled.</p><p>Default: <code class="varname">604800000</code></p></dd><dt><a name="hbase.ipc.client.fallback-to-simple-auth-allowed"></a><code class="varname">hbase.ipc.client.fallback-to-simple-auth-allowed</code></dt><dd><p>When a client is configured to attempt a secure connection, but attempts to
      connect to an insecure server, that server may instruct the client to
      switch to SASL SIMPLE (unsecure) authentication. This setting controls
      whether or not the client will accept this instruction from the server.
      When false (the default), the client will not allow the fallback to SIMPLE
      authentication, and will abort the connection.</p><p>Default: <code class="varname">false</code></p></dd><dt><a name="hbase.coprocessor.region.classes"></a><code class="varname">hbase.coprocessor.region.classes</code></dt><dd><p>A comma-separated list of Coprocessors that are loaded by
    default on all tables. For any override coprocessor method, these classes
    will be called in order. After implementing your own Coprocessor, just put
    it in HBase's classpath and add the fully qualified class name here.
    A coprocessor can also be loaded on demand by setting HTableDescriptor.</p><p>Default: <code class="varname"></code></p></dd><dt><a name="hbase.rest.port"></a><code class="varname">hbase.rest.port</code></dt><dd><p>The port for the HBase REST server.</p><p>Default: <code class="varname">8080</code></p></dd><dt><a name="hbase.rest.readonly"></a><code class="varname">hbase.rest.readonly</code></dt><dd><p>Defines the mode the REST server will be started in. Possible values are:
    false: All HTTP methods are permitted - GET/PUT/POST/DELETE.
    true: Only the GET method is permitted.</p><p>Default: <code class="varname">false</code></p></dd><dt><a name="hbase.rest.threads.max"></a><code class="varname">hbase.rest.threads.max</code></dt><dd><p>The maximum number of threads of the REST server thread pool.
        Threads in the pool are reused to process REST requests. This
        controls the maximum number of requests processed concurrently.
        It may help to control the memory used by the REST server to
        avoid OOM issues. If the thread pool is full, incoming requests
        will be queued up and wait for some free threads.</p><p>Default: <code class="varname">100</code></p></dd><dt><a name="hbase.rest.threads.min"></a><code class="varname">hbase.rest.threads.min</code></dt><dd><p>The minimum number of threads of the REST server thread pool.
        The thread pool always has at least these number of threads so
        the REST server is ready to serve incoming requests.</p><p>Default: <code class="varname">2</code></p></dd><dt><a name="hbase.defaults.for.version.skip"></a><code class="varname">hbase.defaults.for.version.skip</code></dt><dd><p>Set to true to skip the 'hbase.defaults.for.version' check.
    Setting this to true can be useful in contexts other than
    the other side of a maven generation; i.e. running in an
    ide.  You'll want to set this boolean to true to avoid
    seeing the RuntimException complaint: "hbase-default.xml file
    seems to be for and old version of HBase (\${hbase.version}), this
    version is X.X.X-SNAPSHOT"</p><p>Default: <code class="varname">false</code></p></dd><dt><a name="hbase.coprocessor.master.classes"></a><code class="varname">hbase.coprocessor.master.classes</code></dt><dd><p>A comma-separated list of
    org.apache.hadoop.hbase.coprocessor.MasterObserver coprocessors that are
    loaded by default on the active HMaster process. For any implemented
    coprocessor methods, the listed classes will be called in order. After
    implementing your own MasterObserver, just put it in HBase's classpath
    and add the fully qualified class name here.</p><p>Default: <code class="varname"></code></p></dd><dt><a name="hbase.coprocessor.abortonerror"></a><code class="varname">hbase.coprocessor.abortonerror</code></dt><dd><p>Set to true to cause the hosting server (master or regionserver) to
      abort if a coprocessor throws a Throwable object that is not IOException or
      a subclass of IOException. Setting it to true might be useful in development
      environments where one wants to terminate the server as soon as possible to
      simplify coprocessor failure analysis.</p><p>Default: <code class="varname">false</code></p></dd><dt><a name="hbase.online.schema.update.enable"></a><code class="varname">hbase.online.schema.update.enable</code></dt><dd><p>Set true to enable online schema changes.</p><p>Default: <code class="varname">true</code></p></dd><dt><a name="hbase.table.lock.enable"></a><code class="varname">hbase.table.lock.enable</code></dt><dd><p>Set to true to enable locking the table in zookeeper for schema change operations.
    Table locking from master prevents concurrent schema modifications to corrupt table
    state.</p><p>Default: <code class="varname">true</code></p></dd><dt><a name="hbase.thrift.minWorkerThreads"></a><code class="varname">hbase.thrift.minWorkerThreads</code></dt><dd><p>The "core size" of the thread pool. New threads are created on every
    connection until this many threads are created.</p><p>Default: <code class="varname">16</code></p></dd><dt><a name="hbase.thrift.maxWorkerThreads"></a><code class="varname">hbase.thrift.maxWorkerThreads</code></dt><dd><p>The maximum size of the thread pool. When the pending request queue
    overflows, new threads are created until their number reaches this number.
    After that, the server starts dropping connections.</p><p>Default: <code class="varname">1000</code></p></dd><dt><a name="hbase.thrift.maxQueuedRequests"></a><code class="varname">hbase.thrift.maxQueuedRequests</code></dt><dd><p>The maximum number of pending Thrift connections waiting in the queue. If
     there are no idle threads in the pool, the server queues requests. Only
     when the queue overflows, new threads are added, up to
     hbase.thrift.maxQueuedRequests threads.</p><p>Default: <code class="varname">1000</code></p></dd><dt><a name="hbase.thrift.htablepool.size.max"></a><code class="varname">hbase.thrift.htablepool.size.max</code></dt><dd><p>The upper bound for the table pool used in the Thrift gateways server.
      Since this is per table name, we assume a single table and so with 1000 default
      worker threads max this is set to a matching number. For other workloads this number
      can be adjusted as needed.
    </p><p>Default: <code class="varname">1000</code></p></dd><dt><a name="hbase.offheapcache.percentage"></a><code class="varname">hbase.offheapcache.percentage</code></dt><dd><p>The amount of off heap space to be allocated towards the experimental
     off heap cache. If you desire the cache to be disabled, simply set this
     value to 0.</p><p>Default: <code class="varname">0</code></p></dd><dt><a name="hbase.data.umask.enable"></a><code class="varname">hbase.data.umask.enable</code></dt><dd><p>Enable, if true, that file permissions should be assigned
      to the files written by the regionserver</p><p>Default: <code class="varname">false</code></p></dd><dt><a name="hbase.data.umask"></a><code class="varname">hbase.data.umask</code></dt><dd><p>File permissions that should be used to write data
      files when hbase.data.umask.enable is true</p><p>Default: <code class="varname">000</code></p></dd><dt><a name="hbase.metrics.showTableName"></a><code class="varname">hbase.metrics.showTableName</code></dt><dd><p>Whether to include the prefix "tbl.tablename" in per-column family metrics.
	If true, for each metric M, per-cf metrics will be reported for tbl.T.cf.CF.M, if false,
	per-cf metrics will be aggregated by column-family across tables, and reported for cf.CF.M.
	In both cases, the aggregated metric M across tables and cfs will be reported.</p><p>Default: <code class="varname">true</code></p></dd><dt><a name="hbase.metrics.exposeOperationTimes"></a><code class="varname">hbase.metrics.exposeOperationTimes</code></dt><dd><p>Whether to report metrics about time taken performing an
      operation on the region server.  Get, Put, Delete, Increment, and Append can all
      have their times exposed through Hadoop metrics per CF and per region.</p><p>Default: <code class="varname">true</code></p></dd><dt><a name="hbase.snapshot.enabled"></a><code class="varname">hbase.snapshot.enabled</code></dt><dd><p>Set to true to allow snapshots to be taken / restored / cloned.</p><p>Default: <code class="varname">true</code></p></dd><dt><a name="hbase.snapshot.restore.take.failsafe.snapshot"></a><code class="varname">hbase.snapshot.restore.take.failsafe.snapshot</code></dt><dd><p>Set to true to take a snapshot before the restore operation.
      The snapshot taken will be used in case of failure, to restore the previous state.
      At the end of the restore operation this snapshot will be deleted</p><p>Default: <code class="varname">true</code></p></dd><dt><a name="hbase.snapshot.restore.failsafe.name"></a><code class="varname">hbase.snapshot.restore.failsafe.name</code></dt><dd><p>Name of the failsafe snapshot taken by the restore operation.
      You can use the {snapshot.name}, {table.name} and {restore.timestamp} variables
      to create a name based on what you are restoring.</p><p>Default: <code class="varname">hbase-failsafe-{snapshot.name}-{restore.timestamp}</code></p></dd><dt><a name="hbase.server.compactchecker.interval.multiplier"></a><code class="varname">hbase.server.compactchecker.interval.multiplier</code></dt><dd><p>The number that determines how often we scan to see if compaction is necessary.
        Normally, compactions are done after some events (such as memstore flush), but if
        region didn't receive a lot of writes for some time, or due to different compaction
        policies, it may be necessary to check it periodically. The interval between checks is
        hbase.server.compactchecker.interval.multiplier multiplied by
        hbase.server.thread.wakefrequency.</p><p>Default: <code class="varname">1000</code></p></dd><dt><a name="hbase.lease.recovery.timeout"></a><code class="varname">hbase.lease.recovery.timeout</code></dt><dd><p>How long we wait on dfs lease recovery in total before giving up.</p><p>Default: <code class="varname">900000</code></p></dd><dt><a name="hbase.lease.recovery.dfs.timeout"></a><code class="varname">hbase.lease.recovery.dfs.timeout</code></dt><dd><p>How long between dfs recover lease invocations. Should be larger than the sum of
        the time it takes for the namenode to issue a block recovery command as part of
        datanode; dfs.heartbeat.interval and the time it takes for the primary
        datanode, performing block recovery to timeout on a dead datanode; usually
        dfs.socket.timeout. See the end of HBASE-8389 for more.</p><p>Default: <code class="varname">64000</code></p></dd><dt><a name="hbase.dfs.client.read.shortcircuit.buffer.size"></a><code class="varname">hbase.dfs.client.read.shortcircuit.buffer.size</code></dt><dd><p>If the DFSClient configuration
    dfs.client.read.shortcircuit.buffer.size is unset, we will
    use what is configured here as the short circuit read default
    direct byte buffer size. DFSClient native default is 1MB; HBase
    keeps its HDFS files open so number of file blocks * 1MB soon
    starts to add up and threaten OOME because of a shortage of
    direct memory.  So, we set it down from the default.  Make
    it &gt; the default hbase block size set in the HColumnDescriptor
    which is usually 64k.
    </p><p>Default: <code class="varname">131072</code></p></dd><dt><a name="hbase.regionserver.checksum.verify"></a><code class="varname">hbase.regionserver.checksum.verify</code></dt><dd><p>
        If set to true, HBase will read data and then verify checksums for
        hfile blocks. Checksum verification inside HDFS will be switched off.
        If the hbase-checksum verification fails, then it will switch back to
        using HDFS checksums.
    </p><p>Default: <code class="varname">true</code></p></dd><dt><a name="hbase.hstore.bytes.per.checksum"></a><code class="varname">hbase.hstore.bytes.per.checksum</code></dt><dd><p>
        Number of bytes in a newly created checksum chunk for HBase-level
        checksums in hfile blocks.
    </p><p>Default: <code class="varname">16384</code></p></dd><dt><a name="hbase.hstore.checksum.algorithm"></a><code class="varname">hbase.hstore.checksum.algorithm</code></dt><dd><p>
      Name of an algorithm that is used to compute checksums. Possible values
      are NULL, CRC32, CRC32C.
    </p><p>Default: <code class="varname">CRC32</code></p></dd><dt><a name="hbase.status.published"></a><code class="varname">hbase.status.published</code></dt><dd><p>
      This setting activates the publication by the master of the status of the region server.
      When a region server dies and its recovery starts, the master will push this information
      to the client application, to let them cut the connection immediately instead of waiting
      for a timeout.
    </p><p>Default: <code class="varname">false</code></p></dd><dt><a name="hbase.status.publisher.class"></a><code class="varname">hbase.status.publisher.class</code></dt><dd><p>
      Implementation of the status publication with a multicast message.
    </p><p>Default: <code class="varname">org.apache.hadoop.hbase.master.ClusterStatusPublisher$MulticastPublisher</code></p></dd><dt><a name="hbase.status.listener.class"></a><code class="varname">hbase.status.listener.class</code></dt><dd><p>
      Implementation of the status listener with a multicast message.
    </p><p>Default: <code class="varname">org.apache.hadoop.hbase.client.ClusterStatusListener$MulticastListener</code></p></dd><dt><a name="hbase.status.multicast.address.ip"></a><code class="varname">hbase.status.multicast.address.ip</code></dt><dd><p>
      Multicast address to use for the status publication by multicast.
    </p><p>Default: <code class="varname">226.1.1.3</code></p></dd><dt><a name="hbase.status.multicast.address.port"></a><code class="varname">hbase.status.multicast.address.port</code></dt><dd><p>
      Multicast port to use for the status publication by multicast.
    </p><p>Default: <code class="varname">6100</code></p></dd><dt><a name="hbase.dynamic.jars.dir"></a><code class="varname">hbase.dynamic.jars.dir</code></dt><dd><p>
      The directory from which the custom filter/co-processor jars can be loaded
      dynamically by the region server without the need to restart. However,
      an already loaded filter/co-processor class would not be un-loaded. See
      HBASE-1936 for more details.
    </p><p>Default: <code class="varname">${hbase.rootdir}/lib</code></p></dd><dt><a name="hbase.security.authentication"></a><code class="varname">hbase.security.authentication</code></dt><dd><p>
      Controls whether or not secure authentication is enabled for HBase.
      Possible values are 'simple' (no authentication), and 'kerberos'.
    </p><p>Default: <code class="varname">simple</code></p></dd><dt><a name="hbase.rest.filter.classes"></a><code class="varname">hbase.rest.filter.classes</code></dt><dd><p>
      Servlet filters for REST service.
    </p><p>Default: <code class="varname">org.apache.hadoop.hbase.rest.filter.GzipFilter</code></p></dd><dt><a name="hbase.master.loadbalancer.class"></a><code class="varname">hbase.master.loadbalancer.class</code></dt><dd><p>
      Class used to execute the regions balancing when the period occurs.
      See the class comment for more on how it works
      http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/balancer/StochasticLoadBalancer.html
      It replaces the DefaultLoadBalancer as the default (since renamed
      as the SimpleLoadBalancer).
    </p><p>Default: <code class="varname">org.apache.hadoop.hbase.master.balancer.StochasticLoadBalancer</code></p></dd></dl></div></div></div><div class="section" title="1.3.2.&nbsp;hbase-env.sh"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.env.sh"></a>1.3.2.&nbsp;<code class="filename">hbase-env.sh</code></h3></div></div></div><p>Set HBase environment variables in this file.
      Examples include options to pass the JVM on start of
      an HBase daemon such as heap size and garbarge collector configs.
      You can also set configurations for HBase configuration, log directories,
      niceness, ssh options, where to locate process pid files,
      etc. Open the file at
      <code class="filename">conf/hbase-env.sh</code> and peruse its content.
      Each option is fairly well documented.  Add your own environment
      variables here if you want them read by HBase daemons on startup.</p><p>
      Changes here will require a cluster restart for HBase to notice the change.
      </p></div><div class="section" title="1.3.3.&nbsp;log4j.properties"><div class="titlepage"><div><div><h3 class="title"><a name="log4j"></a>1.3.3.&nbsp;<code class="filename">log4j.properties</code></h3></div></div></div><p>Edit this file to change rate at which HBase files
      are rolled and to change the level at which HBase logs messages.
      </p><p>
      Changes here will require a cluster restart for HBase to notice the change
      though log levels can be changed for particular daemons via the HBase UI.
      </p></div><div class="section" title="1.3.4.&nbsp;Client configuration and dependencies connecting to an HBase cluster"><div class="titlepage"><div><div><h3 class="title"><a name="client_dependencies"></a>1.3.4.&nbsp;Client configuration and dependencies connecting to an HBase cluster</h3></div></div></div><p>If you are running HBase in standalone mode, you don't need to configure anything for your client to work
             provided that they are all on the same machine.</p><p>
          Since the HBase Master may move around, clients bootstrap by looking to ZooKeeper for
          current critical locations.  ZooKeeper is where all these values are kept.  Thus clients
          require the location of the ZooKeeper ensemble information before they can do anything else.
          Usually this the ensemble location is kept out in the <code class="filename">hbase-site.xml</code> and
          is picked up by the client from the <code class="varname">CLASSPATH</code>.</p><p>If you are configuring an IDE to run a HBase client, you should
            include the <code class="filename">conf/</code> directory on your classpath so
            <code class="filename">hbase-site.xml</code> settings can be found (or
            add <code class="filename">src/test/resources</code> to pick up the hbase-site.xml
            used by tests).
      </p><p>
          Minimally, a client of HBase needs several libraries in its <code class="varname">CLASSPATH</code> when connecting to a cluster, including:
          </p><pre class="programlisting">
commons-configuration (commons-configuration-1.6.jar)
commons-lang (commons-lang-2.5.jar)
commons-logging (commons-logging-1.1.1.jar)
hadoop-core (hadoop-core-1.0.0.jar)
hbase (hbase-0.92.0.jar)
log4j (log4j-1.2.16.jar)
slf4j-api (slf4j-api-1.5.8.jar)
slf4j-log4j (slf4j-log4j12-1.5.8.jar)
zookeeper (zookeeper-3.4.2.jar)</pre><p>
      </p><p>
          An example basic <code class="filename">hbase-site.xml</code> for client only
          might look as follows:
          </p><pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
    &lt;value&gt;example1,example2,example3&lt;/value&gt;
    &lt;description&gt;The directory shared by region servers.
    &lt;/description&gt;
  &lt;/property&gt;
&lt;/configuration&gt;
</pre><p>
        </p><div class="section" title="1.3.4.1.&nbsp;Java client configuration"><div class="titlepage"><div><div><h4 class="title"><a name="java.client.config"></a>1.3.4.1.&nbsp;Java client configuration</h4></div></div></div><p>The configuration used by a Java client is kept
        in an <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HBaseConfiguration" target="_top">HBaseConfiguration</a> instance.
        The factory method on HBaseConfiguration, <code class="code">HBaseConfiguration.create();</code>,
        on invocation, will read in the content of the first <code class="filename">hbase-site.xml</code> found on
        the client's <code class="varname">CLASSPATH</code>, if one is present
        (Invocation will also factor in any <code class="filename">hbase-default.xml</code> found;
        an hbase-default.xml ships inside the <code class="filename">hbase.X.X.X.jar</code>).
        It is also possible to specify configuration directly without having to read from a
        <code class="filename">hbase-site.xml</code>.  For example, to set the ZooKeeper
        ensemble for the cluster programmatically do as follows:
        </p><pre class="programlisting">Configuration config = HBaseConfiguration.create();
config.set("hbase.zookeeper.quorum", "localhost");  // Here we are running zookeeper locally</pre><p>
        If multiple ZooKeeper instances make up your ZooKeeper ensemble,
        they may be specified in a comma-separated list (just as in the <code class="filename">hbase-site.xml</code> file).
        This populated <code class="classname">Configuration</code> instance can then be passed to an
        <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a>,
        and so on.
        </p></div></div></div><div class="section" title="1.4.&nbsp;Example Configurations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example_config"></a>1.4.&nbsp;Example Configurations</h2></div></div></div><div class="section" title="1.4.1.&nbsp;Basic Distributed HBase Install"><div class="titlepage"><div><div><h3 class="title"><a name="d4651e2390"></a>1.4.1.&nbsp;Basic Distributed HBase Install</h3></div></div></div><p>Here is an example basic configuration for a distributed ten
        node cluster. The nodes are named <code class="varname">example0</code>,
        <code class="varname">example1</code>, etc., through node
        <code class="varname">example9</code> in this example. The HBase Master and the
        HDFS namenode are running on the node <code class="varname">example0</code>.
        RegionServers run on nodes
        <code class="varname">example1</code>-<code class="varname">example9</code>. A 3-node
        ZooKeeper ensemble runs on <code class="varname">example1</code>,
        <code class="varname">example2</code>, and <code class="varname">example3</code> on the
        default ports. ZooKeeper data is persisted to the directory
        <code class="filename">/export/zookeeper</code>. Below we show what the main
        configuration files -- <code class="filename">hbase-site.xml</code>,
        <code class="filename">regionservers</code>, and
        <code class="filename">hbase-env.sh</code> -- found in the HBase
        <code class="filename">conf</code> directory might look like.</p><div class="section" title="1.4.1.1.&nbsp;hbase-site.xml"><div class="titlepage"><div><div><h4 class="title"><a name="hbase_site"></a>1.4.1.1.&nbsp;<code class="filename">hbase-site.xml</code></h4></div></div></div><pre class="programlisting">

&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
    &lt;value&gt;example1,example2,example3&lt;/value&gt;
    &lt;description&gt;The directory shared by RegionServers.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;
    &lt;value&gt;/export/zookeeper&lt;/value&gt;
    &lt;description&gt;Property from ZooKeeper's config zoo.cfg.
    The directory where the snapshot is stored.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.rootdir&lt;/name&gt;
    &lt;value&gt;hdfs://example0:8020/hbase&lt;/value&gt;
    &lt;description&gt;The directory shared by RegionServers.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
    &lt;description&gt;The mode the cluster will be in. Possible values are
      false: standalone and pseudo-distributed setups with managed Zookeeper
      true: fully-distributed with unmanaged Zookeeper Quorum (see hbase-env.sh)
    &lt;/description&gt;
  &lt;/property&gt;
&lt;/configuration&gt;

    </pre></div><div class="section" title="1.4.1.2.&nbsp;regionservers"><div class="titlepage"><div><div><h4 class="title"><a name="regionservers"></a>1.4.1.2.&nbsp;<code class="filename">regionservers</code></h4></div></div></div><p>In this file you list the nodes that will run RegionServers.
          In our case, these nodes are <code class="varname">example1</code>-<code class="varname">example9</code>.
          </p><pre class="programlisting">
    example1
    example2
    example3
    example4
    example5
    example6
    example7
    example8
    example9
    </pre></div><div class="section" title="1.4.1.3.&nbsp;hbase-env.sh"><div class="titlepage"><div><div><h4 class="title"><a name="hbase_env"></a>1.4.1.3.&nbsp;<code class="filename">hbase-env.sh</code></h4></div></div></div><p>Below we use a <span class="command"><strong>diff</strong></span> to show the differences
          from default in the <code class="filename">hbase-env.sh</code> file. Here we
          are setting the HBase heap to be 4G instead of the default
          1G.</p><pre class="programlisting">

$ git diff hbase-env.sh
diff --git a/conf/hbase-env.sh b/conf/hbase-env.sh
index e70ebc6..96f8c27 100644
--- a/conf/hbase-env.sh
+++ b/conf/hbase-env.sh
@@ -31,7 +31,7 @@ export JAVA_HOME=/usr/lib//jvm/java-6-sun/
 # export HBASE_CLASSPATH=

 # The maximum amount of heap to use, in MB. Default is 1000.
-# export HBASE_HEAPSIZE=1000
+export HBASE_HEAPSIZE=4096

 # Extra Java runtime options.
 # Below are what we set by default.  May only work with SUN JVM.

    </pre><p>Use <span class="command"><strong>rsync</strong></span> to copy the content of the
          <code class="filename">conf</code> directory to all nodes of the
          cluster.</p></div></div></div><div class="section" title="1.5.&nbsp;The Important Configurations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="important_configurations"></a>1.5.&nbsp;The Important Configurations</h2></div></div></div><p>Below we list what the <span class="emphasis"><em>important</em></span>
      Configurations.  We've divided this section into
      required configuration and worth-a-look recommended configs.
      </p><div class="section" title="1.5.1.&nbsp;Required Configurations"><div class="titlepage"><div><div><h3 class="title"><a name="required_configuration"></a>1.5.1.&nbsp;Required Configurations</h3></div></div></div><p>Review the <a class="xref" href="#os" title="1.1.2.&nbsp;Operating System">Section&nbsp;1.1.2, &#8220;Operating System&#8221;</a> and <a class="xref" href="#hadoop" title="1.1.3.&nbsp;Hadoop">Section&nbsp;1.1.3, &#8220;Hadoop&#8221;</a> sections.
      </p><div class="section" title="1.5.1.1.&nbsp;Big Cluster Configurations"><div class="titlepage"><div><div><h4 class="title"><a name="big.cluster.config"></a>1.5.1.1.&nbsp;Big Cluster Configurations</h4></div></div></div><p>If a cluster with a lot of regions, it is possible if an eager beaver
            regionserver checks in soon after master start while all the rest in the
            cluster are laggardly, this first server to checkin will be assigned all
            regions.  If lots of regions, this first server could buckle under the
            load.  To prevent the above scenario happening up the
            <code class="varname">hbase.master.wait.on.regionservers.mintostart</code> from its
            default value of 1.  See
            <a class="link" href="https://issues.apache.org/jira/browse/HBASE-6389" target="_top">HBASE-6389 Modify the conditions to ensure that Master waits for sufficient number of Region Servers before starting region assignments</a>
            for more detail.
        </p></div><div class="section" title="1.5.1.2.&nbsp;If a backup Master, making primary Master fail fast"><div class="titlepage"><div><div><h4 class="title"><a name="backup.master.fail.fast"></a>1.5.1.2.&nbsp;If a backup Master, making primary Master fail fast</h4></div></div></div><p>If the primary Master loses its connection with ZooKeeper, it will fall into a loop where it
              keeps trying to reconnect.  Disable this functionality if you are running more than one Master:
              i.e. a backup Master.  Failing to do so, the dying Master may continue to receive RPCs though
              another Master has assumed the role of primary.
              See the configuration <a class="xref" href="#fail.fast.expired.active.master" title="fail.fast.expired.active.master"><code class="varname">fail.fast.expired.active.master</code></a>.

        </p></div></div><div class="section" title="1.5.2.&nbsp;Recommended Configurations"><div class="titlepage"><div><div><h3 class="title"><a name="recommended_configurations"></a>1.5.2.&nbsp;Recommended Configurations</h3></div></div></div><div class="section" title="1.5.2.1.&nbsp;ZooKeeper Configuration"><div class="titlepage"><div><div><h4 class="title"><a name="recommended_configurations.zk"></a>1.5.2.1.&nbsp;ZooKeeper Configuration</h4></div></div></div><div class="section" title="1.5.2.1.1.&nbsp;zookeeper.session.timeout"><div class="titlepage"><div><div><h5 class="title"><a name="zookeeper.session.timeout"></a>1.5.2.1.1.&nbsp;<code class="varname">zookeeper.session.timeout</code></h5></div></div></div><p>The default timeout is three minutes (specified in milliseconds). This means
              that if a server crashes, it will be three minutes before the Master notices
              the crash and starts recovery. You might like to tune the timeout down to
              a minute or even less so the Master notices failures the sooner.
              Before changing this value, be sure you have your JVM garbage collection
              configuration under control otherwise, a long garbage collection that lasts
              beyond the ZooKeeper session timeout will take out
              your RegionServer (You might be fine with this -- you probably want recovery to start
          on the server if a RegionServer has been in GC for a long period of time).</p><p>To change this configuration, edit <code class="filename">hbase-site.xml</code>,
          copy the changed file around the cluster and restart.</p><p>We set this value high to save our having to field noob questions up on the mailing lists asking
              why a RegionServer went down during a massive import.  The usual cause is that their JVM is untuned and
              they are running into long GC pauses.  Our thinking is that
              while users are  getting familiar with HBase, we'd save them having to know all of its
              intricacies.  Later when they've built some confidence, then they can play
              with configuration such as this.
          </p></div><div class="section" title="1.5.2.1.2.&nbsp;Number of ZooKeeper Instances"><div class="titlepage"><div><div><h5 class="title"><a name="zookeeper.instances"></a>1.5.2.1.2.&nbsp;Number of ZooKeeper Instances</h5></div></div></div><p>See <a class="xref" href="#">???</a>.
          </p></div></div><div class="section" title="1.5.2.2.&nbsp;HDFS Configurations"><div class="titlepage"><div><div><h4 class="title"><a name="recommended.configurations.hdfs"></a>1.5.2.2.&nbsp;HDFS Configurations</h4></div></div></div><div class="section" title="1.5.2.2.1.&nbsp;dfs.datanode.failed.volumes.tolerated"><div class="titlepage"><div><div><h5 class="title"><a name="dfs.datanode.failed.volumes.tolerated"></a>1.5.2.2.1.&nbsp;dfs.datanode.failed.volumes.tolerated</h5></div></div></div><p>This is the "...number of volumes that are allowed to fail before a datanode stops offering service. By default
                  any volume failure will cause a datanode to shutdown" from the <code class="filename">hdfs-default.xml</code>
                  description.  If you have &gt; three or four disks, you might want to set this to 1 or if you have many disks,
                  two or more.
              </p></div></div><div class="section" title="1.5.2.3.&nbsp;hbase.regionserver.handler.count"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.handler.count"></a>1.5.2.3.&nbsp;<code class="varname">hbase.regionserver.handler.count</code></h4></div></div></div><p>
          This setting defines the number of threads that are kept open to answer
          incoming requests to user tables. The rule of thumb is to keep this
          number low when the payload per request approaches the MB (big puts, scans using
          a large cache) and high when the payload is small (gets, small puts, ICVs, deletes).
          The total size of the queries in progress is limited  by the setting
          "ipc.server.max.callqueue.size".
          </p><p>
          It is safe to set that number to the
          maximum number of incoming clients if their payload is small, the typical example
          being a cluster that serves a website since puts aren't typically buffered
          and most of the operations are gets.
          </p><p>
          The reason why it is dangerous to keep this setting high is that the aggregate
          size of all the puts that are currently happening in a region server may impose
          too much pressure on its memory, or even trigger an OutOfMemoryError. A region server
          running on low memory will trigger its JVM's garbage collector to run more frequently
          up to a point where GC pauses become noticeable (the reason being that all the memory
          used to keep all the requests' payloads cannot be trashed, no matter how hard the
          garbage collector tries). After some time, the overall cluster
          throughput is affected since every request that hits that region server will take longer,
          which exacerbates the problem even more.
          </p><p>You can get a sense of whether you have too little or too many handlers by
            <a class="xref" href="#">???</a>
            on an individual RegionServer then tailing its logs (Queued requests
            consume memory).
            </p></div><div class="section" title="1.5.2.4.&nbsp;Configuration for large memory machines"><div class="titlepage"><div><div><h4 class="title"><a name="big_memory"></a>1.5.2.4.&nbsp;Configuration for large memory machines</h4></div></div></div><p>
          HBase ships with a reasonable, conservative configuration that will
          work on nearly all
          machine types that people might want to test with. If you have larger
          machines -- HBase has 8G and larger heap -- you might the following configuration options helpful.
          TODO.
        </p></div><div class="section" title="1.5.2.5.&nbsp;Compression"><div class="titlepage"><div><div><h4 class="title"><a name="config.compression"></a>1.5.2.5.&nbsp;Compression</h4></div></div></div><p>You should consider enabling ColumnFamily compression.  There are several options that are near-frictionless and in most all cases boost
      performance by reducing the size of StoreFiles and thus reducing I/O.
      </p><p>See <a class="xref" href="#">???</a> for more information.</p></div><div class="section" title="1.5.2.6.&nbsp;Configuring the size and number of WAL files"><div class="titlepage"><div><div><h4 class="title"><a name="config.wals"></a>1.5.2.6.&nbsp;Configuring the size and number of WAL files</h4></div></div></div><p>HBase uses <a class="xref" href="#">???</a> to recover the memstore data that has not been flushed to disk in case of an RS failure. These WAL files should be configured to be slightly smaller than HDFS block (by default, HDFS block is 64Mb and WAL file is ~60Mb).</p><p>HBase also has a limit on number of WAL files, designed to ensure there's never too much data that needs to be replayed during recovery. This limit needs to be set according to memstore configuration, so that all the necessary data would fit. It is recommended to allocated enough WAL files to store at least that much data (when all memstores are close to full).
      For example, with 16Gb RS heap, default memstore settings (0.4), and default WAL file size (~60Mb), 16Gb*0.4/60, the starting point for WAL file count is ~109.
      However, as all memstores are not expected to be full all the time, less WAL files can be allocated.</p></div><div class="section" title="1.5.2.7.&nbsp;Managed Splitting"><div class="titlepage"><div><div><h4 class="title"><a name="disable.splitting"></a>1.5.2.7.&nbsp;Managed Splitting</h4></div></div></div><p>
      Rather than let HBase auto-split your Regions, manage the splitting manually
      <sup>[<a name="d4651e2594" href="#ftn.d4651e2594" class="footnote">11</a>]</sup>.
 With growing amounts of data, splits will continually be needed. Since
 you always know exactly what regions you have, long-term debugging and
 profiling is much easier with manual splits. It is hard to trace the logs to
 understand region level problems if it keeps splitting and getting renamed.
 Data offlining bugs + unknown number of split regions == oh crap! If an
 <code class="classname">HLog</code> or <code class="classname">StoreFile</code>
 was mistakenly unprocessed by HBase due to a weird bug and
 you notice it a day or so later, you can be assured that the regions
 specified in these files are the same as the current regions and you have
 less headaches trying to restore/replay your data.
 You can finely tune your compaction algorithm. With roughly uniform data
 growth, it's easy to cause split / compaction storms as the regions all
 roughly hit the same data size at the same time. With manual splits, you can
 let staggered, time-based major compactions spread out your network IO load.
      </p><p>
 How do I turn off automatic splitting? Automatic splitting is determined by the configuration value
 <code class="code">hbase.hregion.max.filesize</code>. It is not recommended that you set this
 to <code class="varname">Long.MAX_VALUE</code> in case you forget about manual splits. A suggested setting
 is 100GB, which would result in &gt; 1hr major compactions if reached.
 </p><p>What's the optimal number of pre-split regions to create?
 Mileage will vary depending upon your application.
 You could start low with 10 pre-split regions / server and watch as data grows
 over time. It's better to err on the side of too little regions and rolling split later.
 A more complicated answer is that this depends upon the largest storefile
 in your region. With a growing data size, this will get larger over time. You
 want the largest region to be just big enough that the <code class="classname">Store</code> compact
 selection algorithm only compacts it due to a timed major. If you don't, your
 cluster can be prone to compaction storms as the algorithm decides to run
 major compactions on a large series of regions all at once. Note that
 compaction storms are due to the uniform data growth, not the manual split
 decision.
 </p><p> If you pre-split your regions too thin, you can increase the major compaction
interval by configuring <code class="varname">HConstants.MAJOR_COMPACTION_PERIOD</code>. If your data size
grows too large, use the (post-0.90.0 HBase) <code class="classname">org.apache.hadoop.hbase.util.RegionSplitter</code>
script to perform a network IO safe rolling split
of all regions.
</p></div><div class="section" title="1.5.2.8.&nbsp;Managed Compactions"><div class="titlepage"><div><div><h4 class="title"><a name="managed.compactions"></a>1.5.2.8.&nbsp;Managed Compactions</h4></div></div></div><p>A common administrative technique is to manage major compactions manually, rather than letting
      HBase do it.  By default, <code class="varname">HConstants.MAJOR_COMPACTION_PERIOD</code> is one day and major compactions
      may kick in when you least desire it - especially on a busy system.  To turn off automatic major compactions set
      the value to <code class="varname">0</code>.
      </p><p>It is important to stress that major compactions are absolutely necessary for StoreFile cleanup, the only variant is when
      they occur.  They can be administered through the HBase shell, or via
      <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HBaseAdmin.html#majorCompact%28java.lang.String%29" target="_top">HBaseAdmin</a>.
      </p><p>For more information about compactions and the compaction file selection process, see <a class="xref" href="#">???</a></p></div><div class="section" title="1.5.2.9.&nbsp;Speculative Execution"><div class="titlepage"><div><div><h4 class="title"><a name="spec.ex"></a>1.5.2.9.&nbsp;Speculative Execution</h4></div></div></div><p>Speculative Execution of MapReduce tasks is on by default, and for HBase clusters it is generally advised to turn off
        Speculative Execution at a system-level unless you need it for a specific case, where it can be configured per-job.
        Set the properties <code class="varname">mapred.map.tasks.speculative.execution</code> and
        <code class="varname">mapred.reduce.tasks.speculative.execution</code> to false.
        </p></div></div><div class="section" title="1.5.3.&nbsp;Other Configurations"><div class="titlepage"><div><div><h3 class="title"><a name="other_configuration"></a>1.5.3.&nbsp;Other Configurations</h3></div></div></div><div class="section" title="1.5.3.1.&nbsp;Balancer"><div class="titlepage"><div><div><h4 class="title"><a name="balancer_config"></a>1.5.3.1.&nbsp;Balancer</h4></div></div></div><p>The balancer is a periodic operation which is run on the master to redistribute regions on the cluster.  It is configured via
           <code class="varname">hbase.balancer.period</code> and defaults to 300000 (5 minutes). </p><p>See <a class="xref" href="#">???</a> for more information on the LoadBalancer.
           </p></div><div class="section" title="1.5.3.2.&nbsp;Disabling Blockcache"><div class="titlepage"><div><div><h4 class="title"><a name="disabling.blockcache"></a>1.5.3.2.&nbsp;Disabling Blockcache</h4></div></div></div><p>Do not turn off block cache (You'd do it by setting <code class="varname">hbase.block.cache.size</code> to zero).
           Currently we do not do well if you do this because the regionserver will spend all its time loading hfile
           indices over and over again.  If your working set it such that block cache does you no good, at least
           size the block cache such that hfile indices will stay up in the cache (you can get a rough idea
           on the size you need by surveying regionserver UIs; you'll see index block size accounted near the
           top of the webpage).</p></div><div class="section" title="1.5.3.3.&nbsp;Nagle's or the small package problem"><div class="titlepage"><div><div><h4 class="title"><a name="nagles"></a>1.5.3.3.&nbsp;<a class="link" href="http://en.wikipedia.org/wiki/Nagle's_algorithm" target="_top">Nagle's</a> or the small package problem</h4></div></div></div><p>If a big 40ms or so occasional delay is seen in operations against HBase,
      try the Nagles' setting.  For example, see the user mailing list thread,
      <a class="link" href="http://search-hadoop.com/m/pduLg2fydtE/Inconsistent+scan+performance+with+caching+set+&amp;subj=Re+Inconsistent+scan+performance+with+caching+set+to+1" target="_top">Inconsistent scan performance with caching set to 1</a>
      and the issue cited therein where setting notcpdelay improved scan speeds.  You might also
      see the graphs on the tail of <a class="link" href="https://issues.apache.org/jira/browse/HBASE-7008" target="_top">HBASE-7008 Set scanner caching to a better default</a>
      where our Lars Hofhansl tries various data sizes w/ Nagle's on and off measuring the effect.</p></div><div class="section" title="1.5.3.4.&nbsp;Better Mean Time to Recover (MTTR)"><div class="titlepage"><div><div><h4 class="title"><a name="mttr"></a>1.5.3.4.&nbsp;Better Mean Time to Recover (MTTR)</h4></div></div></div><p>See the Deveraj Das an Nicolas Liochon blog post
          <a class="link" href="http://hortonworks.com/blog/introduction-to-hbase-mean-time-to-recover-mttr/" target="_top">Introduction to HBase Mean Time to Recover (MTTR)</a>
          for a brief introduction.  The issue <a class="link" href="https://issues.apache.org/jira/browse/HBASE-8389" target="_top">HBASE-8354 forces Namenode into loop with lease recovery requests</a>
          is messy but has a bunch of good discussion toward the end on low timeouts and how to effect faster recovery including citation of fixes
          added to HDFS.  Read the Varun Sharma comments.</p></div></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.d4651e14" href="#d4651e14" class="para">1</a>] </sup>
Be careful editing XML.  Make sure you close all elements.
Run your file through <span class="command"><strong>xmllint</strong></span> or similar
to ensure well-formedness of your document after an edit session.
</p></div><div class="footnote"><p><sup>[<a id="ftn.d4651e63" href="#d4651e63" class="para">2</a>] </sup>The <a class="link" href="https://github.com/sujee/hadoop-dns-checker" target="_top">hadoop-dns-checker</a> tool can be used to verify
        DNS is working correctly on the cluster.  The project README file provides detailed instructions on usage.
</p></div><div class="footnote"><p><sup>[<a id="ftn.d4651e128" href="#d4651e128" class="para">3</a>] </sup>See Jack Levin's <a class="link" href="" target="_top">major hdfs issues</a>
                note up on the user list.</p></div><div class="footnote"><p><sup>[<a id="ftn.d4651e135" href="#d4651e135" class="para">4</a>] </sup>The requirement that a database requires upping of system limits
        is not peculiar to Apache HBase.  See for example the section
        <span class="emphasis"><em>Setting Shell Limits for the Oracle User</em></span> in
        <a class="link" href="http://www.akadia.com/services/ora_linux_install_10g.html" target="_top">
        Short Guide to install Oracle 10 on Linux</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.d4651e147" href="#d4651e147" class="para">5</a>] </sup>A useful read setting config on you hadoop cluster is Aaron
            Kimballs' Configuration
            Parameters: What can you just ignore?</p></div><div class="footnote"><p><sup>[<a id="ftn.d4651e352" href="#d4651e352" class="para">6</a>] </sup>See <a class="link" href="http://search-hadoop.com/m/7vFVx4EsUb2" target="_top">HBase, mail # dev - DISCUSS: Have hbase require at least hadoop 1.0.0 in hbase 0.96.0?</a></p></div><div class="footnote"><p><sup>[<a id="ftn.d4651e366" href="#d4651e366" class="para">7</a>] </sup>The Cloudera blog post <a class="link" href="http://www.cloudera.com/blog/2012/01/an-update-on-apache-hadoop-1-0/" target="_top">An update on Apache Hadoop 1.0</a>
          by Charles Zedlweski has a nice exposition on how all the Hadoop versions relate.
          Its worth checking out if you are having trouble making sense of the
          Hadoop version morass.
          </p></div><div class="footnote"><p><sup>[<a id="ftn.d4651e425" href="#d4651e425" class="para">8</a>] </sup>See <a class="link" href="http://ccgtech.blogspot.com/2010/02/hadoop-hdfs-deceived-by-xciever.html" target="_top">Hadoop HDFS: Deceived by Xciever</a> for an informative rant on xceivering.</p></div><div class="footnote"><p><sup>[<a id="ftn.d4651e481" href="#d4651e481" class="para">9</a>] </sup>The pseudo-distributed vs fully-distributed nomenclature
            comes from Hadoop.</p></div><div class="footnote"><p><sup>[<a id="ftn.d4651e567" href="#d4651e567" class="para">10</a>] </sup>See <a class="xref" href="#pseudo.extras" title="1.2.2.1.1.&nbsp;Pseudo-distributed Extras">Section&nbsp;1.2.2.1.1, &#8220;Pseudo-distributed Extras&#8221;</a> for notes on how to start extra Masters and
              RegionServers when running pseudo-distributed.</p></div><div class="footnote"><p><sup>[<a id="ftn.d4651e2594" href="#d4651e2594" class="para">11</a>] </sup>What follows is taken from the javadoc at the head of
      the <code class="classname">org.apache.hadoop.hbase.util.RegionSplitter</code> tool
      added to HBase post-0.90.0 release.
      </p></div></div></div><div id="disqus_thread"></div><script type="text/javascript">
    var disqus_shortname = 'hbase'; // required: replace example with your forum shortname
    var disqus_url = 'http://hbase.apache.org/book';
    var disqus_identifier = 'configuration';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></body></html>